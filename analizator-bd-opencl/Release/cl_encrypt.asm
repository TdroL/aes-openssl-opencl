; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\tdrol\documents\visual studio 2010\Projects\analizator\analizator-bd-opencl\cl_encrypt.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$codecvt@DDH@std@@8			; std::codecvt<char,char,int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$codecvt@DDH@std@@8			; std::codecvt<char,char,int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$codecvt@DDH@std@@8		; std::codecvt<char,char,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$codecvt@DDH@std@@@8			; std::codecvt<char,char,int> `RTTI Type Descriptor'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R4codecvt_base@std@@6B@			; std::codecvt_base::`RTTI Complete Object Locator'
PUBLIC	??_R3codecvt_base@std@@8			; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2codecvt_base@std@@8			; std::codecvt_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@codecvt_base@std@@8		; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVcodecvt_base@std@@@8			; std::codecvt_base `RTTI Type Descriptor'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0BB@GKNLBPKG@?4?1aes?9encrypt?4cl?$AA@	; `string'
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sgetn
PUBLIC	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z ; std::basic_istream<char,std::char_traits<char> >::read
PUBLIC	?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff
PUBLIC	?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ ; std::basic_istream<char,std::char_traits<char> >::tellg
PUBLIC	??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
PUBLIC	?clear@ios_base@std@@QAEXH@Z			; std::ios_base::clear
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z ; std::make_error_code
PUBLIC	?_Makestr@system_error@std@@AAEXXZ		; std::system_error::_Makestr
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
PUBLIC	??0ios_base@std@@IAE@XZ				; std::ios_base::ios_base
PUBLIC	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
PUBLIC	??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
PUBLIC	??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
PUBLIC	??0locale@std@@QAE@XZ				; std::locale::locale
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::is_open
PUBLIC	?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_fstream<char,std::char_traits<char> >::is_open
PUBLIC	??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
PUBLIC	??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
PUBLIC	??_Gios_base@std@@UAEPAXI@Z			; std::ios_base::`scalar deleting destructor'
PUBLIC	??1ios_base@std@@UAE@XZ				; std::ios_base::~ios_base
PUBLIC	??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
PUBLIC	??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??_Glocale@std@@QAEPAXI@Z			; std::locale::`scalar deleting destructor'
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
PUBLIC	??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
PUBLIC	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::out
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::in
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
PUBLIC	??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
PUBLIC	?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z	; std::codecvt<char,char,int>::unshift
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	??0?$fpos@H@std@@QAE@_J@Z			; std::fpos<int>::fpos<int>
PUBLIC	??0?$fpos@H@std@@QAE@H_J@Z			; std::fpos<int>::fpos<int>
PUBLIC	?state@?$fpos@H@std@@QBEHXZ			; std::fpos<int>::state
PUBLIC	?seekpos@?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::seekpos
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?always_noconv@codecvt_base@std@@QBE_NXZ	; std::codecvt_base::always_noconv
PUBLIC	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??0runtime_error@std@@QAE@PBD@Z			; std::runtime_error::runtime_error
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??0codecvt_base@std@@QAE@I@Z			; std::codecvt_base::codecvt_base
PUBLIC	?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z	; std::codecvt<char,char,int>::_Init
PUBLIC	?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_in
PUBLIC	?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_out
PUBLIC	?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ; std::codecvt<char,char,int>::do_unshift
PUBLIC	?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z	; std::codecvt<char,char,int>::do_length
PUBLIC	??_Gfacet@locale@std@@UAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
PUBLIC	?do_always_noconv@codecvt_base@std@@MBE_NXZ	; std::codecvt_base::do_always_noconv
PUBLIC	?do_max_length@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_max_length
PUBLIC	?do_encoding@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_encoding
PUBLIC	??_Gcodecvt_base@std@@UAEPAXI@Z			; std::codecvt_base::`scalar deleting destructor'
PUBLIC	??1codecvt_base@std@@UAE@XZ			; std::codecvt_base::~codecvt_base
PUBLIC	??1?$codecvt@DDH@std@@MAE@XZ			; std::codecvt<char,char,int>::~codecvt<char,char,int>
PUBLIC	??_G?$codecvt@DDH@std@@MAEPAXI@Z		; std::codecvt<char,char,int>::`scalar deleting destructor'
PUBLIC	??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z	; std::codecvt<char,char,int>::codecvt<char,char,int>
PUBLIC	?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<char,char,int>::_Getcat
PUBLIC	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??B?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::operator __int64
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	__CTA4?AVfailure@ios_base@std@@
PUBLIC	__TI4?AVfailure@ios_base@std@@
PUBLIC	??_C@_0BK@BBDPOGAD@?9?5Invalid?5argument?5index?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@OJGEJCAL@?5?9?5Invalid?5argument?5data?5size?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@FGIJEIM@?9?5Invalid?5argument?5value?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MJMKIHHI@?9?5Invalid?5command?9queue?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@JMOBBGKG@?9?5Invalid?5context?5or?5buffer?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@HFHFLEOF@?9?5Invalid?5event?9wait?5list?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@MDHOOLED@?5?9?5global_work_offset?5is?5not?5NUL@ ; `string'
PUBLIC	??_C@_0BK@GJKBPDEK@?5?9?5Invalid?5kernel?5object?6?$AA@ ; `string'
PUBLIC	??_C@_0DD@ODPKDFBB@?5?9?5Kernel?5argument?5values?5have?5n@ ; `string'
PUBLIC	??_C@_0BC@JMDFOBPB@?9?5Invalid?5buffer?6?$AA@	; `string'
PUBLIC	??_C@_0BN@ICFPNBPD@?5?9?5No?5valid?5program?5avaible?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@BLAMBFJG@?9?5Invalid?5sampler?5object?6?$AA@ ; `string'
PUBLIC	??_C@_0DM@FFFIJCDB@?9?5Offset?5or?5size?5out?9of?9bounds?5o@ ; `string'
PUBLIC	??_C@_0CC@GEBFDNCA@?5?9?5work_dim?5is?5not?5a?5valid?5value@ ; `string'
PUBLIC	??_C@_0EA@CCADPGGI@?5?9?5global_work_size?5is?5not?5evenl@ ; `string'
PUBLIC	??_C@_0EC@GOFGLOMA@?5?9?5local_work_size?5is?5greater?5th@ ; `string'
PUBLIC	??_C@_0EL@JIBFLOOI@?9?5Failed?5to?5allocate?5or?5read?5mem@ ; `string'
PUBLIC	??_C@_0FK@OFFEAEOE@?9?5Failed?5to?5allocate?5or?5read?5res@ ; `string'
PUBLIC	??_C@_0DF@LKOFKLDO@?5?9?5Nobody?5knows?5what?5happened?5?$CIC@ ; `string'
PUBLIC	??_C@_0CM@DGFADCLC@Error?3?5could?5not?5connect?5to?5comp@ ; `string'
PUBLIC	??_C@_0CO@IBFBJMIF@Warning?3?5no?5GPU?5support?0?5falling@ ; `string'
PUBLIC	??_C@_0CA@JGBMOJJG@Error?3?5could?5not?5get?5device?5id?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@GFFLIIBK@Error?3?5failed?5to?5create?5a?5comput@ ; `string'
PUBLIC	??_C@_0CJ@CDIEGNMJ@Error?3?5failed?5to?5create?5a?5comman@ ; `string'
PUBLIC	??_C@_0BK@OHCKHDJD@Error?3?5failed?5to?5open?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@BCOEJPJH@Error?3?5?$CFs?5is?5empty?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@FJBOGDEN@Error?3?5failed?5to?5create?5compute?5@ ; `string'
PUBLIC	??_C@_0CP@OFECIAMI@Error?3?5failed?5to?5create?5program?5@ ; `string'
PUBLIC	??_C@_0CI@JDNBEOHO@Error?3?5failed?5to?5create?5compute?5@ ; `string'
PUBLIC	??_C@_0DM@EFGFDLFN@Error?3?5failed?5to?5allocate?5device@ ; `string'
PUBLIC	??_C@_0EA@GEPEPEEL@Error?3?5failed?5to?5allocate?5device@ ; `string'
PUBLIC	??_C@_0DF@KBMIDIFJ@Error?3?5failed?5to?5bind?5kernel?5arg@ ; `string'
PUBLIC	??_C@_0DI@CKFCGCAA@Error?3?5failed?5to?5bind?5kernel?5arg@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	?_Stz@?$fpos@H@std@@0HB				; std::fpos<int>::_Stz
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7codecvt_base@std@@6B@			; std::codecvt_base::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`vftable'
EXTRN	__imp__clGetPlatformIDs@12:PROC
EXTRN	__imp__clGetDeviceIDs@24:PROC
EXTRN	__imp__clCreateContext@24:PROC
EXTRN	__imp__clCreateCommandQueue@20:PROC
EXTRN	__imp__clCreateProgramWithSource@20:PROC
EXTRN	__imp__clBuildProgram@24:PROC
EXTRN	__imp__clGetProgramBuildInfo@24:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	?iostream_category@std@@YAABVerror_category@1@XZ:PROC ; std::iostream_category
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	__Getctype:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??0_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::_Mutex
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@XZ:PROC	; std::locale::_Init
EXTRN	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC		; std::_Fiopen
EXTRN	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??1_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::~_Mutex
EXTRN	?_Lock@_Mutex@std@@QAEXXZ:PROC			; std::_Mutex::_Lock
EXTRN	?_Unlock@_Mutex@std@@QAEXXZ:PROC		; std::_Mutex::_Unlock
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	_fclose:PROC
EXTRN	__lock_file:PROC
EXTRN	__unlock_file:PROC
EXTRN	_fputc:PROC
EXTRN	_ungetc:PROC
EXTRN	_memcpy_s:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	_fgetc:PROC
EXTRN	_fgetpos:PROC
EXTRN	_fsetpos:PROC
EXTRN	__fseeki64:PROC
EXTRN	?_BADOFF@std@@3_JB:QWORD			; std::_BADOFF
EXTRN	_fwrite:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	_setvbuf:PROC
EXTRN	_fflush:PROC
EXTRN	??0bad_cast@std@@QAE@PBD@Z:PROC			; std::bad_cast::bad_cast
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?_Facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::_Facet_Register
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	_free:PROC
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	??_Ecodecvt_base@std@@UAEPAXI@Z:PROC		; std::codecvt_base::`vector deleting destructor'
EXTRN	??_E?$codecvt@DDH@std@@MAEPAXI@Z:PROC		; std::codecvt<char,char,int>::`vector deleting destructor'
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_printf:PROC
EXTRN	__imp__clCreateBuffer@24:PROC
EXTRN	__imp__clCreateKernel@12:PROC
EXTRN	__imp__clSetKernelArg@16:PROC
EXTRN	_exit:PROC
EXTRN	__imp__clReleaseMemObject@4:PROC
EXTRN	__imp__clReleaseKernel@4:PROC
EXTRN	__imp__clReleaseContext@4:PROC
EXTRN	__imp__clReleaseCommandQueue@4:PROC
EXTRN	__imp__clReleaseProgram@4:PROC
_err	DD	01H DUP (?)
_platform_id DD	01H DUP (?)
_device_id DD	01H DUP (?)
_context DD	01H DUP (?)
_queue	DD	01H DUP (?)
_program DD	01H DUP (?)
_kernel	DD	01H DUP (?)
_state	DD	01H DUP (?)
_roundkeys DD	01H DUP (?)
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
;	COMDAT ??_7?$codecvt@DDH@std@@6B@
CONST	SEGMENT
??_7?$codecvt@DDH@std@@6B@ DD FLAT:??_R4?$codecvt@DDH@std@@6B@ ; std::codecvt<char,char,int>::`vftable'
	DD	FLAT:??_E?$codecvt@DDH@std@@MAEPAXI@Z
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
	DD	FLAT:?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
CONST	ENDS
;	COMDAT ??_R4?$codecvt@DDH@std@@6B@
rdata$r	SEGMENT
??_R4?$codecvt@DDH@std@@6B@ DD 00H			; std::codecvt<char,char,int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$codecvt@DDH@std@@@8
	DD	FLAT:??_R3?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R3?$codecvt@DDH@std@@8 DD 00H			; std::codecvt<char,char,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R2?$codecvt@DDH@std@@8 DD FLAT:??_R1A@?0A@EA@?$codecvt@DDH@std@@8 ; std::codecvt<char,char,int>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@codecvt_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$codecvt@DDH@std@@8 DD FLAT:??_R0?AV?$codecvt@DDH@std@@@8 ; std::codecvt<char,char,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@DDH@std@@@8
_DATA	SEGMENT
??_R0?AV?$codecvt@DDH@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::codecvt<char,char,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$codecvt@DDH@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT
??_7codecvt_base@std@@6B@ DD FLAT:??_R4codecvt_base@std@@6B@ ; std::codecvt_base::`vftable'
	DD	FLAT:??_Ecodecvt_base@std@@UAEPAXI@Z
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
CONST	ENDS
;	COMDAT ??_R4codecvt_base@std@@6B@
rdata$r	SEGMENT
??_R4codecvt_base@std@@6B@ DD 00H			; std::codecvt_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcodecvt_base@std@@@8
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3codecvt_base@std@@8
rdata$r	SEGMENT
??_R3codecvt_base@std@@8 DD 00H				; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2codecvt_base@std@@8
rdata$r	SEGMENT
??_R2codecvt_base@std@@8 DD FLAT:??_R1A@?0A@EA@codecvt_base@std@@8 ; std::codecvt_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@codecvt_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@codecvt_base@std@@8 DD FLAT:??_R0?AVcodecvt_base@std@@@8 ; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT
??_R0?AVcodecvt_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::codecvt_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcodecvt_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	060H
CONST	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	070H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	018H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
	DD	010H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	010H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
_DATA	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HB
CONST	SEGMENT
?_Stz@?$fpos@H@std@@0HB DD 00H				; std::fpos<int>::_Stz
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CKFCGCAA@Error?3?5failed?5to?5bind?5kernel?5arg@
CONST	SEGMENT
??_C@_0DI@CKFCGCAA@Error?3?5failed?5to?5bind?5kernel?5arg@ DB 'Error: fai'
	DB	'led to bind kernel argument "roundkeys" [#1]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KBMIDIFJ@Error?3?5failed?5to?5bind?5kernel?5arg@
CONST	SEGMENT
??_C@_0DF@KBMIDIFJ@Error?3?5failed?5to?5bind?5kernel?5arg@ DB 'Error: fai'
	DB	'led to bind kernel argument "buffer" [#0]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@GEPEPEEL@Error?3?5failed?5to?5allocate?5device@
CONST	SEGMENT
??_C@_0EA@GEPEPEEL@Error?3?5failed?5to?5allocate?5device@ DB 'Error: fail'
	DB	'ed to allocate device memory (roundkeys, size: %lu)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EFGFDLFN@Error?3?5failed?5to?5allocate?5device@
CONST	SEGMENT
??_C@_0DM@EFGFDLFN@Error?3?5failed?5to?5allocate?5device@ DB 'Error: fail'
	DB	'ed to allocate device memory (state, size: %lu)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JDNBEOHO@Error?3?5failed?5to?5create?5compute?5@
CONST	SEGMENT
??_C@_0CI@JDNBEOHO@Error?3?5failed?5to?5create?5compute?5@ DB 'Error: fai'
	DB	'led to create compute kernel', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OFECIAMI@Error?3?5failed?5to?5create?5program?5@
CONST	SEGMENT
??_C@_0CP@OFECIAMI@Error?3?5failed?5to?5create?5program?5@ DB 'Error: fai'
	DB	'led to create program executable', 0aH, '%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FJBOGDEN@Error?3?5failed?5to?5create?5compute?5@
CONST	SEGMENT
??_C@_0CJ@FJBOGDEN@Error?3?5failed?5to?5create?5compute?5@ DB 'Error: fai'
	DB	'led to create compute program', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BCOEJPJH@Error?3?5?$CFs?5is?5empty?6?$AA@
CONST	SEGMENT
??_C@_0BE@BCOEJPJH@Error?3?5?$CFs?5is?5empty?6?$AA@ DB 'Error: %s is empt'
	DB	'y', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OHCKHDJD@Error?3?5failed?5to?5open?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BK@OHCKHDJD@Error?3?5failed?5to?5open?5?$CFs?6?$AA@ DB 'Error: fai'
	DB	'led to open %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CDIEGNMJ@Error?3?5failed?5to?5create?5a?5comman@
CONST	SEGMENT
??_C@_0CJ@CDIEGNMJ@Error?3?5failed?5to?5create?5a?5comman@ DB 'Error: fai'
	DB	'led to create a command queue', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GFFLIIBK@Error?3?5failed?5to?5create?5a?5comput@
CONST	SEGMENT
??_C@_0CL@GFFLIIBK@Error?3?5failed?5to?5create?5a?5comput@ DB 'Error: fai'
	DB	'led to create a compute context', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JGBMOJJG@Error?3?5could?5not?5get?5device?5id?6?$AA@
CONST	SEGMENT
??_C@_0CA@JGBMOJJG@Error?3?5could?5not?5get?5device?5id?6?$AA@ DB 'Error:'
	DB	' could not get device id', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IBFBJMIF@Warning?3?5no?5GPU?5support?0?5falling@
CONST	SEGMENT
??_C@_0CO@IBFBJMIF@Warning?3?5no?5GPU?5support?0?5falling@ DB 'Warning: n'
	DB	'o GPU support, falling back to CPU', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DGFADCLC@Error?3?5could?5not?5connect?5to?5comp@
CONST	SEGMENT
??_C@_0CM@DGFADCLC@Error?3?5could?5not?5connect?5to?5comp@ DB 'Error: cou'
	DB	'ld not connect to compute device', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LKOFKLDO@?5?9?5Nobody?5knows?5what?5happened?5?$CIC@
CONST	SEGMENT
??_C@_0DF@LKOFKLDO@?5?9?5Nobody?5knows?5what?5happened?5?$CIC@ DB ' - Nob'
	DB	'ody knows what happened (CL_OUT_OF_RESOURCES)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@OFFEAEOE@?9?5Failed?5to?5allocate?5or?5read?5res@
CONST	SEGMENT
??_C@_0FK@OFFEAEOE@?9?5Failed?5to?5allocate?5or?5read?5res@ DB '- Failed '
	DB	'to allocate or read resources required by the OpenCL implemen'
	DB	'tation on the host', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@JIBFLOOI@?9?5Failed?5to?5allocate?5or?5read?5mem@
CONST	SEGMENT
??_C@_0EL@JIBFLOOI@?9?5Failed?5to?5allocate?5or?5read?5mem@ DB '- Failed '
	DB	'to allocate or read memory for data store associated with buf'
	DB	'fer', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@GOFGLOMA@?5?9?5local_work_size?5is?5greater?5th@
CONST	SEGMENT
??_C@_0EC@GOFGLOMA@?5?9?5local_work_size?5is?5greater?5th@ DB ' - local_w'
	DB	'ork_size is greater than CL_DEVICE_MAX_WORK_ITEM_SIZES', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@CCADPGGI@?5?9?5global_work_size?5is?5not?5evenl@
CONST	SEGMENT
??_C@_0EA@CCADPGGI@?5?9?5global_work_size?5is?5not?5evenl@ DB ' - global_'
	DB	'work_size is not evenly divisable by local_work_size', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEBFDNCA@?5?9?5work_dim?5is?5not?5a?5valid?5value@
CONST	SEGMENT
??_C@_0CC@GEBFDNCA@?5?9?5work_dim?5is?5not?5a?5valid?5value@ DB ' - work_'
	DB	'dim is not a valid value', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@FFFIJCDB@?9?5Offset?5or?5size?5out?9of?9bounds?5o@
CONST	SEGMENT
??_C@_0DM@FFFIJCDB@?9?5Offset?5or?5size?5out?9of?9bounds?5o@ DB '- Offset'
	DB	' or size out-of-bounds or *results is a NULL value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BLAMBFJG@?9?5Invalid?5sampler?5object?6?$AA@
CONST	SEGMENT
??_C@_0BK@BLAMBFJG@?9?5Invalid?5sampler?5object?6?$AA@ DB '- Invalid samp'
	DB	'ler object', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ICFPNBPD@?5?9?5No?5valid?5program?5avaible?6?$AA@
CONST	SEGMENT
??_C@_0BN@ICFPNBPD@?5?9?5No?5valid?5program?5avaible?6?$AA@ DB ' - No val'
	DB	'id program avaible', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JMDFOBPB@?9?5Invalid?5buffer?6?$AA@
CONST	SEGMENT
??_C@_0BC@JMDFOBPB@?9?5Invalid?5buffer?6?$AA@ DB '- Invalid buffer', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@ODPKDFBB@?5?9?5Kernel?5argument?5values?5have?5n@
CONST	SEGMENT
??_C@_0DD@ODPKDFBB@?5?9?5Kernel?5argument?5values?5have?5n@ DB ' - Kernel'
	DB	' argument values have not been specified', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GJKBPDEK@?5?9?5Invalid?5kernel?5object?6?$AA@
CONST	SEGMENT
??_C@_0BK@GJKBPDEK@?5?9?5Invalid?5kernel?5object?6?$AA@ DB ' - Invalid ke'
	DB	'rnel object', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MDHOOLED@?5?9?5global_work_offset?5is?5not?5NUL@
CONST	SEGMENT
??_C@_0CD@MDHOOLED@?5?9?5global_work_offset?5is?5not?5NUL@ DB ' - global_'
	DB	'work_offset is not NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HFHFLEOF@?9?5Invalid?5event?9wait?5list?6?$AA@
CONST	SEGMENT
??_C@_0BL@HFHFLEOF@?9?5Invalid?5event?9wait?5list?6?$AA@ DB '- Invalid ev'
	DB	'ent-wait list', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMOBBGKG@?9?5Invalid?5context?5or?5buffer?6?$AA@
CONST	SEGMENT
??_C@_0BN@JMOBBGKG@?9?5Invalid?5context?5or?5buffer?6?$AA@ DB '- Invalid '
	DB	'context or buffer', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MJMKIHHI@?9?5Invalid?5command?9queue?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MJMKIHHI@?9?5Invalid?5command?9queue?6?$AA@ DB '- Invalid comma'
	DB	'nd-queue', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FGIJEIM@?9?5Invalid?5argument?5value?6?$AA@
CONST	SEGMENT
??_C@_0BK@FGIJEIM@?9?5Invalid?5argument?5value?6?$AA@ DB '- Invalid argum'
	DB	'ent value', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OJGEJCAL@?5?9?5Invalid?5argument?5data?5size?6?$AA@
CONST	SEGMENT
??_C@_0BP@OJGEJCAL@?5?9?5Invalid?5argument?5data?5size?6?$AA@ DB ' - Inva'
	DB	'lid argument data size', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BBDPOGAD@?9?5Invalid?5argument?5index?6?$AA@
CONST	SEGMENT
??_C@_0BK@BBDPOGAD@?9?5Invalid?5argument?5index?6?$AA@ DB '- Invalid argu'
	DB	'ment index', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GKNLBPKG@?4?1aes?9encrypt?4cl?$AA@
CONST	SEGMENT
??_C@_0BB@GKNLBPKG@?4?1aes?9encrypt?4cl?$AA@ DB './aes-encrypt.cl', 00H ; `string'
CONST	ENDS
;	COMDAT __TI4?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI4?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT __CTA4?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA4?AVfailure@ios_base@std@@ DD 04H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
_DATA	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
_source	DD	FLAT:??_C@_0BB@GKNLBPKG@?4?1aes?9encrypt?4cl?$AA@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z PROC	; std::codecvt<char,char,int>::_Init, COMDAT

; 863  : 		}

	ret	0
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::codecvt<char,char,int>::_Init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 220  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = eax

; 290  : 		*_IPfirst = _First;

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx], 0

; 291  : 		*_IPnext = _First;

	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx], 0

; 292  : 		*_IPcount = (int)(_Last - _First);

	mov	eax, DWORD PTR [eax+52]
	mov	DWORD PTR [eax], 0

; 293  : 		}

	ret	0
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1517 : 		size_type _Num = this->_Alval.max_size();
; 1518 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1519 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First2$ = 12						; size = 4
__Last2$ = 16						; size = 4
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z PROC	; std::codecvt<char,char,int>::unshift, COMDAT
; _this$ = ecx
; __Mid2$ = edx

; 823  : 		{	// generate bytes to return to default shift state

	push	ebp
	mov	ebp, esp

; 824  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+24]
	push	edx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	edx, DWORD PTR __State$[ebp]
	push	edx
	call	eax

; 825  : 		}

	pop	ebp
	ret	12					; 0000000cH
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::unshift
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*, COMDAT
; _this$ = eax

; 71   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 72   : 		if (this->_Getcont() == 0
; 73   : 			|| this->_Ptr == 0
; 74   : 			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 75   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 76   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 77   : 			{	// report error
; 78   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 79   : 			_SCL_SECURE_OUT_OF_RANGE;
; 80   : 			}
; 81   : 
; 82   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 83   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 84   : 		_SCL_SECURE_VALIDATE_RANGE(
; 85   : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr
; 86   : 			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 87   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 88   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 89   : 
; 90   : 		__analysis_assume(this->_Ptr != 0);
; 91   : 
; 92   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 93   : 		}

	ret	0
??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z
_TEXT	SEGMENT
__Gn$ = 8						; size = 4
__Gc$ = 12						; size = 4
__Pf$ = 16						; size = 4
__Pn$ = 20						; size = 4
__Pc$ = 24						; size = 4
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = eax
; __Gf$ = ecx

; 327  : 		{	// initialize buffer parameters as specified

	push	ebp
	mov	ebp, esp

; 328  : 		_IGfirst = _Gf;
; 329  : 		_IPfirst = _Pf;

	mov	edx, DWORD PTR __Pf$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 330  : 		_IGnext = _Gn;

	mov	ecx, DWORD PTR __Gn$[ebp]
	mov	DWORD PTR [eax+20], edx

; 331  : 		_IPnext = _Pn;

	mov	edx, DWORD PTR __Pn$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 332  : 		_IGcount = _Gc;

	mov	ecx, DWORD PTR __Gc$[ebp]
	mov	DWORD PTR [eax+36], edx

; 333  : 		_IPcount = _Pc;

	mov	edx, DWORD PTR __Pc$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 334  : 		}

	pop	ebp
	ret	20					; 00000014H
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT
; __First$ = edi
; __Next$ = edx
; __Last$ = eax

; 248  : 		{	// set pointers for read buffer

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	esi

; 249  : 		*_IGfirst = _First;

	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi], edi

; 250  : 		*_IGnext = _Next;

	mov	esi, DWORD PTR [ecx+32]
	mov	DWORD PTR [esi], edx

; 251  : 		*_IGcount = (int)(_Last - _Next);

	mov	ecx, DWORD PTR [ecx+48]
	sub	eax, edx
	mov	DWORD PTR [ecx], eax
	pop	esi

; 252  : 		}

	pop	ebp
	ret	4
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = eax

; 74   : 		return (_Tiestr);

	mov	eax, DWORD PTR [eax+60]

; 75   : 		}

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 182  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 183  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2021 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2016 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2003 : 		{	// determine current pointer to buffer for mutable string

	mov	eax, ecx

; 2004 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2005 : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr
	mov	eax, DWORD PTR [eax]
$LN4@Myptr:

; 2006 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Count$ = 20						; size = 4
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z PROC	; std::codecvt<char,char,int>::do_length, COMDAT
; _this$ = ecx

; 890  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))

	push	ebp
	mov	ebp, esp

; 891  : 		return ((int)(_Count < (size_t)(_Last1 - _First1)
; 892  : 			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion

	mov	eax, DWORD PTR __Last1$[ebp]
	sub	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, eax
	jae	SHORT $LN4@do_length
	mov	eax, ecx
$LN4@do_length:

; 893  : 		}

	pop	ebp
	ret	16					; 00000010H
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z ENDP	; std::codecvt<char,char,int>::do_length
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First2$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z PROC	; std::codecvt<char,char,int>::do_unshift, COMDAT
; _this$ = ecx

; 883  : 		{	// generate bytes to return to default shift state

	push	ebp
	mov	ebp, esp

; 884  : 		_Mid2 = _First2;

	mov	eax, DWORD PTR __Mid2$[ebp]
	mov	ecx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR [eax], ecx

; 885  : 		return (noconv);	// convert nothing

	mov	eax, 3

; 886  : 		}

	pop	ebp
	ret	16					; 00000010H
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::do_unshift
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::do_out, COMDAT
; _this$ = ecx

; 876  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)

	push	ebp
	mov	ebp, esp

; 877  : 		_Mid1 = _First1, _Mid2 = _First2;

	mov	eax, DWORD PTR __Mid1$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR __Mid2$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR [edx], eax

; 878  : 		return (noconv);	// convert nothing

	mov	eax, 3

; 879  : 		}

	pop	ebp
	ret	28					; 0000001cH
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_out
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::do_in, COMDAT
; _this$ = ecx

; 868  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)

	push	ebp
	mov	ebp, esp

; 869  : 		_Mid1 = _First1, _Mid2 = _First2;

	mov	eax, DWORD PTR __Mid1$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR __Mid2$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR [edx], eax

; 870  : 		return (noconv);	// convert nothing

	mov	eax, 3

; 871  : 		}

	pop	ebp
	ret	28					; 0000001cH
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_in
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::out, COMDAT
; _this$ = ecx
; __Mid2$ = edx

; 816  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)

	push	ebp
	mov	ebp, esp

; 817  : 		return (do_out(_State,
; 818  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	push	edx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	edx, DWORD PTR __Mid1$[ebp]
	push	edx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	edx, DWORD PTR __State$[ebp]
	push	edx
	call	eax

; 819  : 		}

	pop	ebp
	ret	24					; 00000018H
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::out
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC	; std::codecvt<char,char,int>::in, COMDAT
; _this$ = ecx
; __Mid2$ = edx

; 808  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)

	push	ebp
	mov	ebp, esp

; 809  : 		return (do_in(_State,
; 810  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	edx, DWORD PTR __Mid1$[ebp]
	push	edx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	edx, DWORD PTR __State$[ebp]
	push	edx
	call	eax

; 811  : 		}

	pop	ebp
	ret	24					; 00000018H
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP	; std::codecvt<char,char,int>::in
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*, COMDAT
; _this$ = eax

; 343  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [eax]

; 344  : 		}

	ret	0
??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?seekpos@?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
?seekpos@?$fpos@H@std@@QBE_JXZ PROC			; std::fpos<int>::seekpos, COMDAT
; _this$ = ecx

; 60   : 		return (_Fpos);

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]

; 61   : 		}

	ret	0
?seekpos@?$fpos@H@std@@QBE_JXZ ENDP			; std::fpos<int>::seekpos
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@std@@QBEHXZ
_TEXT	SEGMENT
?state@?$fpos@H@std@@QBEHXZ PROC			; std::fpos<int>::state, COMDAT
; _this$ = eax

; 50   : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+16]

; 51   : 		}

	ret	0
?state@?$fpos@H@std@@QBEHXZ ENDP			; std::fpos<int>::state
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@H_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Fileposition$ = 12					; size = 8
??0?$fpos@H@std@@QAE@H_J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = eax

; 45   : 		{	// construct with conversion state and C file position

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR __Fileposition$[ebp]
	mov	edx, DWORD PTR __Fileposition$[ebp+4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx

; 46   : 		}

	pop	ebp
	ret	12					; 0000000cH
??0?$fpos@H@std@@QAE@H_J@Z ENDP				; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@_J@Z
_TEXT	SEGMENT
??0?$fpos@H@std@@QAE@_J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = eax

; 40   : 		{	// construct with stream offset

	mov	ecx, DWORD PTR ?_BADOFF@std@@3_JB
	mov	edx, DWORD PTR ?_BADOFF@std@@3_JB+4
	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 41   : 		}

	ret	0
??0?$fpos@H@std@@QAE@_J@Z ENDP				; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 212  : 		return (_Myfile != 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+84], eax
	setne	al

; 213  : 		}

	ret	0
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::is_open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = eax

; 310  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Pnavail
	mov	edx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [edx]
	cdq

; 311  : 		}

	ret	0
$LN3@Pnavail:

; 310  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	xor	eax, eax
	cdq

; 311  : 		}

	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 304  : 		--*_IPcount;

	mov	eax, DWORD PTR [ecx+52]
	dec	DWORD PTR [eax]

; 305  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx

; 306  : 		}

	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT
; _this$ = edx
; __Off$ = ecx

; 284  : 		*_IPcount -= _Off;

	mov	eax, DWORD PTR [edx+52]
	sub	DWORD PTR [eax], ecx

; 285  : 		*_IPnext += _Off;

	mov	eax, DWORD PTR [edx+36]
	add	DWORD PTR [eax], ecx

; 286  : 		}

	ret	0
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = eax

; 279  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Gnavail
	mov	edx, DWORD PTR [eax+48]
	mov	eax, DWORD PTR [edx]
	cdq

; 280  : 		}

	ret	0
$LN3@Gnavail:

; 279  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	xor	eax, eax
	cdq

; 280  : 		}

	ret	0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 273  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+48]
	dec	DWORD PTR [eax]

; 274  : 		return (++(*_IGnext));

	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	inc	eax
	mov	DWORD PTR [ecx], eax

; 275  : 		}

	ret	0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 267  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+48]
	dec	DWORD PTR [eax]

; 268  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx

; 269  : 		}

	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec, COMDAT
; _this$ = ecx

; 261  : 		++*_IGcount;

	mov	eax, DWORD PTR [ecx+48]
	inc	DWORD PTR [eax]

; 262  : 		return (--*_IGnext);

	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	dec	eax
	mov	DWORD PTR [ecx], eax

; 263  : 		}

	ret	0
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = eax

; 256  : 		return (*_IPnext + *_IPcount);

	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx]
	add	eax, DWORD PTR [edx]

; 257  : 		}

	ret	0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT
; _this$ = edx
; __Off$ = ecx

; 243  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [edx+48]
	sub	DWORD PTR [eax], ecx

; 244  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [edx+32]
	add	DWORD PTR [eax], ecx

; 245  : 		}

	ret	0
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = eax

; 238  : 		return (*_IGnext + *_IGcount);

	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [ecx]
	add	eax, DWORD PTR [edx]

; 239  : 		}

	ret	0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = eax

; 233  : 		return (*_IPnext);

	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx]

; 234  : 		}

	ret	0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = eax

; 223  : 		return (*_IGnext);

	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [ecx]

; 224  : 		}

	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT
; _this$ = eax

; 218  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx]

; 219  : 		}

	ret	0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPAD_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetn, COMDAT
; _this$ = ecx

; 158  : 		{	// get up to _Count characters into array beginning at _Ptr

	push	ebp
	mov	ebp, esp

; 159  : 		return (xsgetn(_Ptr, _Count));

	mov	edx, DWORD PTR __Count$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	eax

; 160  : 		}

	pop	ebp
	ret	12					; 0000000cH
?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetn
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 141  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+52]
	jmp	edx
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@_JHH@Z
_TEXT	SEGMENT
?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Way$ = edx

; 91   : 		return (seekoff(_Off, _Way, _Mode));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+40]
	push	1
	push	edx
	push	0
	push	0
	push	esi
	call	eax
	mov	eax, esi

; 92   : 		}

	ret	0
?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3391 : 		{	// discard any string

	push	esi
	mov	esi, ecx

; 3392 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 3393 : 
; 3394 :  #ifdef _DEBUG
; 3395 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3396 : 
; 3397 :  #else /* _DEBUG */
; 3398 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 3399 :  #endif /* _DEBUG */
; 3400 : 
; 3401 : 		_Myptr = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 3402 : 		}

	ret	0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

	mov	eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

	mov	eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 459  : 		}

	ret	0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 454  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 455  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1512 : 		return (this->_Mysize);

	mov	eax, DWORD PTR [ecx+16]

; 1513 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@H@std@@QBE_JXZ PROC				; std::fpos<int>::operator __int64, COMDAT
; _this$ = ecx

; 65   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	eax, DWORD PTR [ecx+8]
	cdq
	add	eax, DWORD PTR [ecx]
	adc	edx, DWORD PTR [ecx+4]

; 66   : 		}

	ret	0
??B?$fpos@H@std@@QBE_JXZ ENDP				; std::fpos<int>::operator __int64
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 315  : 		if (_Myfile)

	mov	eax, DWORD PTR [ecx+84]
	test	eax, eax
	je	SHORT $LN1@Unlock

; 316  : 			_CSTD _unlock_file(_Myfile);

	push	eax
	call	__unlock_file
	pop	ecx
$LN1@Unlock:

; 317  : 		}

	ret	0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 309  : 		if (_Myfile)

	mov	eax, DWORD PTR [ecx+84]
	test	eax, eax
	je	SHORT $LN1@Lock

; 310  : 			_CSTD _lock_file(_Myfile);

	push	eax
	call	__lock_file
	pop	ecx
$LN1@Lock:

; 311  : 		}

	ret	0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 1312 : 		return (_Filebuffer.is_open());

	xor	eax, eax
	cmp	DWORD PTR [ecx+108], eax
	setne	al

; 1313 : 		}

	ret	0
?is_open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::is_open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 445  : 		}

	ret	4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 440  : 		return (0);

	xor	eax, eax

; 441  : 		}

	ret	0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 434  : 		{	// offer buffer to external agent (do nothing)

	mov	eax, ecx

; 435  : 		return (this);
; 436  : 		}

	ret	12					; 0000000cH
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 429  : 		{	// change to specified position, according to mode

	push	ebp
	mov	ebp, esp

; 430  : 		return (streampos(_BADOFF));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?_BADOFF@std@@3_JB
	mov	edx, DWORD PTR ?_BADOFF@std@@3_JB+4
	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 431  : 		}

	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 423  : 		{	// change position by offset, according to way and mode

	push	ebp
	mov	ebp, esp

; 424  : 		return (streampos(_BADOFF));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?_BADOFF@std@@3_JB
	mov	edx, DWORD PTR ?_BADOFF@std@@3_JB+4
	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 425  : 		}

	pop	ebp
	ret	20					; 00000014H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 348  : 		return (0);

	xor	eax, eax
	xor	edx, edx

; 349  : 		}

	ret	0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 212  : 		_Mylock._Unlock();

	add	ecx, 4
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 207  : 		_Mylock._Lock();

	add	ecx, 4
	jmp	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*, COMDAT
; _this$ = ecx

; 105  : 			return (_Ok ? _CONVERTIBLE_TO_TRUE : 0);

	xor	eax, eax
	cmp	BYTE PTR [ecx+4], al
	setne	al
	dec	eax

; 106  : 			}

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 63   : 		{	// destroy the object

	mov	eax, DWORD PTR [ecx-16]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@

; 64   : 		}

	ret	0
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = eax

; 86   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+56]

; 87   : 		}

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

	mov	eax, DWORD PTR [ecx-8]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 80   : 		}

	ret	0
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3376 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN4@c_str
	lea	eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3377 : 		}

	ret	0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3365 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 3366 : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn
	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:
	mov	DWORD PTR [esi], 0
	pop	esi

; 3367 : 		}

	ret	0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = eax

; 3315 : 		{	// default construct

	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 3316 : 		}

	ret	0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
PUBLIC	?cl_release_kernel@@YAXXZ			; cl_release_kernel
; Function compile flags: /Ogtp
; File c:\users\tdrol\documents\visual studio 2010\projects\analizator\analizator-bd-opencl\cl_encrypt.cpp
;	COMDAT ?cl_release_kernel@@YAXXZ
_TEXT	SEGMENT
?cl_release_kernel@@YAXXZ PROC				; cl_release_kernel, COMDAT

; 194  : 	if (state != nullptr)

	mov	eax, DWORD PTR _state
	push	esi
	mov	esi, DWORD PTR __imp__clReleaseMemObject@4
	test	eax, eax
	je	SHORT $LN3@cl_release

; 195  : 	{
; 196  : 		clReleaseMemObject(state);

	push	eax
	call	esi

; 197  : 		state = nullptr;

	mov	DWORD PTR _state, 0
$LN3@cl_release:

; 198  : 	}
; 199  : 	
; 200  : 	if (roundkeys != nullptr)

	mov	eax, DWORD PTR _roundkeys
	test	eax, eax
	je	SHORT $LN2@cl_release

; 201  : 	{
; 202  : 		clReleaseMemObject(roundkeys);

	push	eax
	call	esi

; 203  : 		roundkeys = nullptr;

	mov	DWORD PTR _roundkeys, 0
$LN2@cl_release:

; 204  : 	}
; 205  : 
; 206  : 	if (kernel != nullptr)

	mov	eax, DWORD PTR _kernel
	pop	esi
	test	eax, eax
	je	SHORT $LN1@cl_release

; 207  : 	{
; 208  : 		clReleaseKernel(kernel);

	push	eax
	call	DWORD PTR __imp__clReleaseKernel@4

; 209  : 		kernel = nullptr;

	mov	DWORD PTR _kernel, 0
$LN1@cl_release:

; 210  : 	}
; 211  : }

	ret	0
?cl_release_kernel@@YAXXZ ENDP				; cl_release_kernel
_TEXT	ENDS
PUBLIC	?cl_encrypt@@YAXPAEI0I@Z			; cl_encrypt
; Function compile flags: /Ogtp
;	COMDAT ?cl_encrypt@@YAXPAEI0I@Z
_TEXT	SEGMENT
?cl_encrypt@@YAXPAEI0I@Z PROC				; cl_encrypt, COMDAT

; 189  : 	
; 190  : }

	ret	0
?cl_encrypt@@YAXPAEI0I@Z ENDP				; cl_encrypt
_TEXT	ENDS
PUBLIC	?cl_print_error@@YAXH@Z				; cl_print_error
; Function compile flags: /Ogtp
;	COMDAT ?cl_print_error@@YAXH@Z
_TEXT	SEGMENT
?cl_print_error@@YAXH@Z PROC				; cl_print_error, COMDAT

; 21   : 	switch (err)

	mov	eax, DWORD PTR _err
	add	eax, 57					; 00000039H
	cmp	eax, 53					; 00000035H
	ja	$LN20@cl_print_e
	movzx	eax, BYTE PTR $LN24@cl_print_e[eax]
	jmp	DWORD PTR $LN25@cl_print_e[eax*4]
$LN19@cl_print_e:

; 22   : 	{
; 23   : 		case CL_INVALID_ARG_INDEX: printf("- Invalid argument index\n"); break;

	push	OFFSET ??_C@_0BK@BBDPOGAD@?9?5Invalid?5argument?5index?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN18@cl_print_e:

; 24   : 		case CL_INVALID_ARG_SIZE: printf(" - Invalid argument data size\n"); break;

	push	OFFSET ??_C@_0BP@OJGEJCAL@?5?9?5Invalid?5argument?5data?5size?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN17@cl_print_e:

; 25   : 		case CL_INVALID_ARG_VALUE: printf("- Invalid argument value\n"); break;

	push	OFFSET ??_C@_0BK@FGIJEIM@?9?5Invalid?5argument?5value?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN16@cl_print_e:

; 26   : 		case CL_INVALID_COMMAND_QUEUE: printf("- Invalid command-queue\n"); break;

	push	OFFSET ??_C@_0BJ@MJMKIHHI@?9?5Invalid?5command?9queue?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN15@cl_print_e:

; 27   : 		case CL_INVALID_CONTEXT: printf("- Invalid context or buffer\n"); break;

	push	OFFSET ??_C@_0BN@JMOBBGKG@?9?5Invalid?5context?5or?5buffer?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN14@cl_print_e:

; 28   : 		case CL_INVALID_EVENT_WAIT_LIST: printf("- Invalid event-wait list\n"); break;

	push	OFFSET ??_C@_0BL@HFHFLEOF@?9?5Invalid?5event?9wait?5list?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN13@cl_print_e:

; 29   : 		case CL_INVALID_GLOBAL_OFFSET: printf(" - global_work_offset is not NULL\n"); break;

	push	OFFSET ??_C@_0CD@MDHOOLED@?5?9?5global_work_offset?5is?5not?5NUL@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN12@cl_print_e:

; 30   : 		case CL_INVALID_KERNEL: printf(" - Invalid kernel object\n"); break;

	push	OFFSET ??_C@_0BK@GJKBPDEK@?5?9?5Invalid?5kernel?5object?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN11@cl_print_e:

; 31   : 		case CL_INVALID_KERNEL_ARGS: printf(" - Kernel argument values have not been specified\n"); break;

	push	OFFSET ??_C@_0DD@ODPKDFBB@?5?9?5Kernel?5argument?5values?5have?5n@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN10@cl_print_e:

; 32   : 		case CL_INVALID_MEM_OBJECT: printf("- Invalid buffer\n"); break;

	push	OFFSET ??_C@_0BC@JMDFOBPB@?9?5Invalid?5buffer?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN9@cl_print_e:

; 33   : 		case CL_INVALID_PROGRAM_EXECUTABLE: printf(" - No valid program avaible\n"); break;

	push	OFFSET ??_C@_0BN@ICFPNBPD@?5?9?5No?5valid?5program?5avaible?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN8@cl_print_e:

; 34   : 		case CL_INVALID_SAMPLER: printf("- Invalid sampler object\n"); break;

	push	OFFSET ??_C@_0BK@BLAMBFJG@?9?5Invalid?5sampler?5object?6?$AA@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN7@cl_print_e:

; 35   : 		case CL_INVALID_VALUE: printf("- Offset or size out-of-bounds or *results is a NULL value\n"); break;

	push	OFFSET ??_C@_0DM@FFFIJCDB@?9?5Offset?5or?5size?5out?9of?9bounds?5o@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN6@cl_print_e:

; 36   : 		case CL_INVALID_WORK_DIMENSION: printf(" - work_dim is not a valid value\n"); break;

	push	OFFSET ??_C@_0CC@GEBFDNCA@?5?9?5work_dim?5is?5not?5a?5valid?5value@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN5@cl_print_e:

; 37   : 		case CL_INVALID_WORK_GROUP_SIZE: printf(" - global_work_size is not evenly divisable by local_work_size\n"); break;

	push	OFFSET ??_C@_0EA@CCADPGGI@?5?9?5global_work_size?5is?5not?5evenl@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN4@cl_print_e:

; 38   : 		case CL_INVALID_WORK_ITEM_SIZE: printf(" - local_work_size is greater than CL_DEVICE_MAX_WORK_ITEM_SIZES\n"); break;

	push	OFFSET ??_C@_0EC@GOFGLOMA@?5?9?5local_work_size?5is?5greater?5th@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN3@cl_print_e:

; 39   : 		case CL_MEM_OBJECT_ALLOCATION_FAILURE: printf("- Failed to allocate or read memory for data store associated with buffer\n"); break;

	push	OFFSET ??_C@_0EL@JIBFLOOI@?9?5Failed?5to?5allocate?5or?5read?5mem@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN2@cl_print_e:

; 40   : 		case CL_OUT_OF_HOST_MEMORY: printf("- Failed to allocate or read resources required by the OpenCL implementation on the host\n"); break;

	push	OFFSET ??_C@_0FK@OFFEAEOE@?9?5Failed?5to?5allocate?5or?5read?5res@
	call	_printf
	add	esp, 4

; 42   : 	}
; 43   : }

	ret	0
$LN1@cl_print_e:

; 41   : 		case CL_OUT_OF_RESOURCES: printf(" - Nobody knows what happened (CL_OUT_OF_RESOURCES)\n"); break;

	push	OFFSET ??_C@_0DF@LKOFKLDO@?5?9?5Nobody?5knows?5what?5happened?5?$CIC@
	call	_printf
	pop	ecx
$LN20@cl_print_e:

; 42   : 	}
; 43   : }

	ret	0
	npad	1
$LN25@cl_print_e:
	DD	$LN14@cl_print_e
	DD	$LN13@cl_print_e
	DD	$LN4@cl_print_e
	DD	$LN5@cl_print_e
	DD	$LN6@cl_print_e
	DD	$LN11@cl_print_e
	DD	$LN18@cl_print_e
	DD	$LN17@cl_print_e
	DD	$LN19@cl_print_e
	DD	$LN12@cl_print_e
	DD	$LN9@cl_print_e
	DD	$LN8@cl_print_e
	DD	$LN10@cl_print_e
	DD	$LN16@cl_print_e
	DD	$LN15@cl_print_e
	DD	$LN7@cl_print_e
	DD	$LN2@cl_print_e
	DD	$LN1@cl_print_e
	DD	$LN3@cl_print_e
	DD	$LN20@cl_print_e
$LN24@cl_print_e:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	10					; 0000000aH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	11					; 0000000bH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	12					; 0000000cH
	DB	19					; 00000013H
	DB	13					; 0000000dH
	DB	19					; 00000013H
	DB	14					; 0000000eH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	15					; 0000000fH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
?cl_print_error@@YAXH@Z ENDP				; cl_print_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = eax

; 105  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

	movzx	edx, BYTE PTR [ecx]
	push	eax
	push	edx
	call	_ungetc
	xor	ecx, ecx
	add	esp, 8
	cmp	eax, -1
	setne	al

; 106  : 	}

	ret	0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT
; __Byte$ = ecx
; __File$ = eax

; 81   : 	return (fputc(_Byte, _File) != EOF);

	movsx	ecx, cl
	push	eax
	push	ecx
	call	_fputc
	xor	edx, edx
	add	esp, 8
	cmp	eax, -1
	setne	al

; 82   : 	}

	ret	0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 4
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT
; __File$ = eax

; 35   : 	{	// get a char element from a C stream

	push	ebp
	mov	ebp, esp

; 36   : 	int _Meta;
; 37   : 	if ((_Meta = fgetc(_File)) == EOF)

	push	eax
	call	_fgetc
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN2@Fgetc

; 38   : 		return (false);

	xor	al, al

; 43   : 		}
; 44   : 	}

	pop	ebp
	ret	0
$LN2@Fgetc:

; 39   : 	else
; 40   : 		{	// got one, convert to char
; 41   : 		_Byte = (char)_Meta;

	mov	ecx, DWORD PTR __Byte$[ebp]
	mov	BYTE PTR [ecx], al

; 42   : 		return (true);

	mov	al, 1

; 43   : 		}
; 44   : 	}

	pop	ebp
	ret	0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
??0ios_base@std@@IAE@XZ PROC				; std::ios_base::ios_base, COMDAT
; _this$ = eax

; 549  : 	__CLR_OR_THIS_CALL ios_base()

	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 550  : 		{	// default constructor
; 551  : 		}

	ret	0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ios_base@std@@UAE@XZ PROC				; std::ios_base::~ios_base, COMDAT
; _this$ = ecx

; 541  : 		_Ios_base_dtor(this);

	push	ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	pop	ecx

; 542  : 		}

	ret	0
??1ios_base@std@@UAE@XZ ENDP				; std::ios_base::~ios_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = eax

; 395  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [eax+20]

; 396  : 		}

	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = eax

; 336  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+12]

; 337  : 		}

	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
_TEXT	ENDS
;	COMDAT ?_Makestr@system_error@std@@AAEXXZ
_TEXT	SEGMENT
?_Makestr@system_error@std@@AAEXXZ PROC			; std::system_error::_Makestr, COMDAT

; 563  : //		_Mymes = this->runtime_error::what();
; 564  : //		if (!_Mymes.empty())
; 565  : //			_Mymes.append(": ");
; 566  : //		_Mymes.append(_Mycode.message());
; 567  : 		}

	ret	0
?_Makestr@system_error@std@@AAEXXZ ENDP			; std::system_error::_Makestr
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = eax
; __Cat$ = ecx

; 204  : 		{	// construct from error code and category

	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [eax+4], ecx

; 205  : 		}

	ret	0
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2460 : 		{	// narrow elements in [_First, _Last) to chars

	push	ebp
	mov	ebp, esp

; 2461 : 		_DEBUG_RANGE(_First, _Last);
; 2462 : 		_DEBUG_POINTER(_Dest);
; 2463 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	push	esi
	mov	esi, DWORD PTR __Last$[ebp]
	mov	ecx, esi
	sub	ecx, eax
	push	ecx
	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2464 : 		return (_Last);

	mov	eax, esi
	pop	esi

; 2465 : 		}

	pop	ebp
	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2454 : 		{	// narrow char

	push	ebp
	mov	ebp, esp

; 2455 : 		return (_Ch);

	mov	al, BYTE PTR __Ch$[ebp]

; 2456 : 		}

	pop	ebp
	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2446 : 		{	// widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2447 : 		_DEBUG_RANGE(_First, _Last);
; 2448 : 		_DEBUG_POINTER(_Dest);
; 2449 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	push	esi
	mov	esi, DWORD PTR __Last$[ebp]
	mov	ecx, esi
	sub	ecx, eax
	push	ecx
	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2450 : 		return (_Last);

	mov	eax, esi
	pop	esi

; 2451 : 		}

	pop	ebp
	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2440 : 		{	// widen char

	push	ebp
	mov	ebp, esp

; 2441 : 		return (_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 2442 : 		}

	pop	ebp
	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2432 : 		{	// convert [_First, _Last) in place to upper case

	push	ebp
	mov	ebp, esp
	push	ebx

; 2433 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2434 : 		for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[ebp]
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	cmp	esi, ebx
	je	SHORT $LN8@do_toupper
	push	edi
	lea	edi, DWORD PTR [ecx+8]
$LL3@do_toupper:

; 2435 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	edi
	push	eax
	call	__Toupper
	mov	BYTE PTR [esi], al
	inc	esi
	add	esp, 8
	cmp	esi, ebx
	jne	SHORT $LL3@do_toupper
	pop	edi
$LN8@do_toupper:

; 2436 : 		return ((const _Elem *)_First);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2437 : 		}

	pop	ebp
	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2426 : 		{	// convert element to upper case

	push	ebp
	mov	ebp, esp

; 2427 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

	movzx	eax, BYTE PTR __Ch$[ebp]
	add	ecx, 8
	push	ecx
	push	eax
	call	__Toupper
	add	esp, 8

; 2428 : 		}

	pop	ebp
	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2418 : 		{	// convert [_First, _Last) in place to lower case

	push	ebp
	mov	ebp, esp
	push	ebx

; 2419 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2420 : 		for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[ebp]
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	cmp	esi, ebx
	je	SHORT $LN8@do_tolower
	push	edi
	lea	edi, DWORD PTR [ecx+8]
$LL3@do_tolower:

; 2421 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	edi
	push	eax
	call	__Tolower
	mov	BYTE PTR [esi], al
	inc	esi
	add	esp, 8
	cmp	esi, ebx
	jne	SHORT $LL3@do_tolower
	pop	edi
$LN8@do_tolower:

; 2422 : 		return ((const _Elem *)_First);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2423 : 		}

	pop	ebp
	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2412 : 		{	// convert element to lower case

	push	ebp
	mov	ebp, esp

; 2413 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

	movzx	eax, BYTE PTR __Ch$[ebp]
	add	ecx, 8
	push	ecx
	push	eax
	call	__Tolower
	add	esp, 8

; 2414 : 		}

	pop	ebp
	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2405 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	jle	SHORT $LN6@Tidy@2

; 2406 : 			free((void *)_Ctype._Table);

	mov	eax, DWORD PTR [ecx+16]
	push	eax
	call	_free
	add	esp, 4

; 2409 : 		}

	ret	0
$LN6@Tidy@2:

; 2407 : 		else if (_Ctype._Delfl < 0)

	jns	SHORT $LN1@Tidy@2

; 2408 : 			delete[] (void *)_Ctype._Table;

	mov	ecx, DWORD PTR [ecx+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN1@Tidy@2:

; 2409 : 		}

	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2325 : 		return (do_widen(_Byte));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+24]
	push	32					; 00000020H
	call	edx

; 2326 : 		}

	ret	0
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx
; __Ch$ = eax

; 2272 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, al
	test	BYTE PTR [edx+eax*2], 72		; 00000048H
	mov	eax, 0
	setne	al

; 2273 : 		}

	ret	0
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_encoding@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_encoding, COMDAT
; _this$ = ecx

; 787  : 		return (1);	// -1 ==> state dependent, 0 ==> varying length

	mov	eax, 1

; 788  : 		}

	ret	0
?do_encoding@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_encoding
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_max_length@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_max_length, COMDAT
; _this$ = ecx

; 782  : 		return (1);

	mov	eax, 1

; 783  : 		}

	ret	0
?do_max_length@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_max_length
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT
?do_always_noconv@codecvt_base@std@@MBE_NXZ PROC	; std::codecvt_base::do_always_noconv, COMDAT
; _this$ = ecx

; 777  : 		return (true);

	mov	al, 1

; 778  : 		}

	ret	0
?do_always_noconv@codecvt_base@std@@MBE_NXZ ENDP	; std::codecvt_base::do_always_noconv
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?always_noconv@codecvt_base@std@@QBE_NXZ
_TEXT	SEGMENT
?always_noconv@codecvt_base@std@@QBE_NXZ PROC		; std::codecvt_base::always_noconv, COMDAT
; _this$ = ecx

; 757  : 		return (do_always_noconv());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	jmp	edx
?always_noconv@codecvt_base@std@@QBE_NXZ ENDP		; std::codecvt_base::always_noconv
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = eax
; __Id$ = esi

; 437  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 438  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+esi*4]

; 439  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	eax, eax
	jne	SHORT $LN1@Getfacet
$LN10@Getfacet:
	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN1@Getfacet

; 440  : 			return (_Facptr);	// found facet or not transparent
; 441  : 		else
; 442  : 			{	// look in current locale
; 443  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 444  : 			return (_Id < _Ptr->_Facetcount
; 445  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 446  : 				: 0);	// no entry in current locale

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 447  : 			}
; 448  : 		}

	ret	0
$LN6@Getfacet:

; 437  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 438  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	eax, eax

; 439  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	jmp	SHORT $LN10@Getfacet
$LN8@Getfacet:

; 444  : 			return (_Id < _Ptr->_Facetcount
; 445  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 446  : 				: 0);	// no entry in current locale

	xor	eax, eax
$LN1@Getfacet:

; 447  : 			}
; 448  : 		}

	ret	0
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = eax

; 432  : 		return (_Ptr->_Name.c_str());

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN6@c_str@2
	lea	eax, DWORD PTR [ecx+28]
$LN6@c_str@2:

; 433  : 		}

	ret	0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 170  : 			{	// construct with initial reference count

	push	ebp
	mov	ebp, esp
	mov	eax, ecx
	mov	ecx, DWORD PTR __Initrefs$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
	mov	DWORD PTR [eax+4], ecx

; 171  : 			}

	pop	ebp
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@UAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 164  : 			{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@

; 165  : 			}

	ret	0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = eax

; 129  :  #if defined(_M_CEE)
; 130  : 			_Facet_Register_m(this);
; 131  : 
; 132  :  #else /* defined(_M_CEE) */
; 133  : 			_Facet_Register(this);

	push	eax
	call	?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
	pop	ecx

; 134  :  #endif /* defined(_M_CEE) */
; 135  : 			}

	ret	0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
__Lock$16219 = -4					; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC		; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 119  : 			{	// safely decrement the reference count, return this when dead

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 120  : 			_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$16219[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 121  : 				if (0 < _Refs && _Refs < (size_t)(-1))

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN1@Decref
	cmp	eax, -1
	jae	SHORT $LN1@Decref

; 122  : 					--_Refs;

	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN1@Decref:

; 123  : 				return (_Refs == 0 ? this : 0);

	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$16219[ebp]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi

; 124  : 			_END_LOCK()
; 125  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$16214 = -4					; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 111  : 			{	// safely increment the reference count

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 112  : 			_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$16214[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 113  : 				if (_Refs < (size_t)(-1))

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN1@Incref

; 114  : 					++_Refs;

	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN1@Incref:

; 115  : 			_END_LOCK()

	lea	ecx, DWORD PTR __Lock$16214[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	esi

; 116  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$16208 = -4					; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = esi

; 75   : 			{	// get stamp, with lazy allocation

	push	ebp
	mov	ebp, esp
	push	ecx

; 76   : 			if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@operator

; 77   : 				{	// still zero, allocate stamp
; 78   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$16208[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 79   : 					if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN1@operator

; 80   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR [esi], eax
$LN1@operator:

; 81   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$16208[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN6@operator:

; 82   : 				}
; 83   : 			return (_Id);

	mov	eax, DWORD PTR [esi]

; 84   : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 71   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	mov	eax, ecx
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 72   : 			}

	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T29946 = -16						; size = 16
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; ___$ReturnUdt$ = esi

; 117  : 		{	// return ctype stuff

	push	ebp
	mov	ebp, esp

; 118  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T29946[ebp]
	sub	esp, 16					; 00000010H
	push	eax
	call	__Getctype
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [eax+8]
	add	esp, 4
	movq	QWORD PTR [esi+8], xmm0
	mov	eax, esi

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1_Locinfo@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1_Locinfo@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT

; 93   :         {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Locinfo@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[ebp]

; 94   :         _Locinfo_dtor(this);

	push	esi
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 95   :         }

	mov	eax, DWORD PTR [esi+28]
	xor	edi, edi
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN10@Locinfo
	push	eax
	call	_free
	add	esp, 4
$LN10@Locinfo:
	mov	DWORD PTR [esi+28], edi
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	je	SHORT $LN15@Locinfo
	push	eax
	call	_free
	add	esp, 4
$LN15@Locinfo:
	mov	DWORD PTR [esi+20], edi
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edi
	je	SHORT $LN20@Locinfo
	push	eax
	call	_free
	add	esp, 4
$LN20@Locinfo:
	mov	DWORD PTR [esi+12], edi
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN25@Locinfo
	push	eax
	call	_free
	add	esp, 4
$LN25@Locinfo:
	mov	ecx, esi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??1_Locinfo@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Ogtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 170  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	esi
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 171  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 49   : 		}

	ret	0
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 563  : 		return (EOF);

	or	eax, -1

; 564  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 558  : 		return (_Meta != eof() ? _Meta : !eof());

	xor	eax, eax

; 559  : 		}

	ret	0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = eax
; __Right$ = edx

; 553  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 554  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT
; __Ch$ = eax

; 547  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [eax]

; 548  : 		}

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = eax

; 542  : 		return ((_Elem)_Meta);

	mov	al, BYTE PTR [eax]

; 543  : 		}

	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 527  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [edx], cl

; 528  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Count$ = eax
; __Ch$ = ecx

; 521  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 522  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	mov	edx, DWORD PTR __First$[ebp]
	movsx	ecx, cl
	push	eax
	push	ecx
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 523  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 516  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 518  : 		}

	pop	ebp

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 498  : 		}

	pop	ebp

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	esi
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T30107 = -12						; size = 12
$T30111 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

	je	SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	ecx, -1
	ja	SHORT $LN1@Allocate
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	eax, DWORD PTR $T30111[ebp]
	push	eax
	lea	ecx, DWORD PTR $T30107[ebp]
	mov	DWORD PTR $T30111[ebp], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T30107[ebp]
	push	ecx
	mov	DWORD PTR $T30107[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@Allocate:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T30129 = -12						; size = 12
$T30121 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate
	cmp	ecx, -1
	ja	SHORT $LN3@allocate
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate
$LN3@allocate:
	lea	eax, DWORD PTR $T30121[ebp]
	push	eax
	lea	ecx, DWORD PTR $T30129[ebp]
	mov	DWORD PTR $T30121[ebp], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T30129[ebp]
	push	ecx
	mov	DWORD PTR $T30129[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@allocate:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 51   : 		{	// construct with pointer _Parg
; 52   : 		this->_Adopt(_Pstring);
; 53   : 		this->_Ptr = _Parg;

	mov	DWORD PTR [eax], ecx

; 54   : 		}

	ret	0
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 325  : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 326  : 		}

	ret	0
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = eax

; 315  : 		_IGfirst = &_Gfirst;
; 316  : 		_IPfirst = &_Pfirst;
; 317  : 		_IGnext = &_Gnext;

	lea	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+32], edx

; 318  : 		_IPnext = &_Pnext;

	lea	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+36], edx
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+16], ecx

; 319  : 		_IGcount = &_Gcount;

	lea	edx, DWORD PTR [eax+40]
	mov	DWORD PTR [eax+48], edx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+20], ecx

; 320  : 		_IPcount = &_Pcount;

	lea	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+52], edx

; 321  : 		setp(0, 0);

	mov	DWORD PTR [ecx], 0
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx], 0

; 322  : 		setg(0, 0, 0);

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [eax+48]
	mov	DWORD PTR [eax], 0

; 323  : 		}

	ret	0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1953 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 1954 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jb	SHORT $LN5@Eos
	mov	ecx, DWORD PTR [ecx]
$LN5@Eos:
	mov	BYTE PTR [ecx+eax], 0

; 1955 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; __Off$ = esi
; __Count$ = ecx
; __Ch$ = edx

; 1911 : 		{	// assign _Count copies of _Ch beginning at _Off

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _this$[ebp]

; 1912 : 		if (_Count == 1)

	cmp	ecx, 1
	jne	SHORT $LN2@Chassign

; 1913 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN7@Chassign
	mov	eax, DWORD PTR [eax]
$LN7@Chassign:
	mov	BYTE PTR [eax+esi], dl

; 1916 : 		}

	pop	ebp
	ret	4
$LN2@Chassign:

; 1914 : 		else
; 1915 : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN13@Chassign
	mov	eax, DWORD PTR [eax]
$LN13@Chassign:
	push	ecx
	movsx	ecx, dl
	push	ecx
	add	eax, esi
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1916 : 		}

	pop	ebp
	ret	4
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; _this$ = eax

; 647  : 		if (_Mysb::eback() != &_Mychar)

	mov	edx, DWORD PTR [eax+16]
	push	esi
	mov	esi, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+72]
	cmp	esi, ecx
	je	SHORT $LN1@Set_back

; 648  : 			{	// save current get buffer
; 649  : 			_Set_eback = _Mysb::eback();

	mov	DWORD PTR [eax+60], esi

; 650  : 			_Set_egptr = _Mysb::egptr();

	mov	esi, DWORD PTR [eax+48]
	mov	esi, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [eax+32]
	add	esi, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+64], esi
$LN1@Set_back:

; 651  : 			}
; 652  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx], ecx
	mov	edx, eax
	mov	eax, DWORD PTR [eax+48]
	sub	edx, ecx
	add	edx, 73					; 00000049H
	mov	DWORD PTR [eax], edx
	pop	esi

; 653  : 		}

	ret	0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = eax

; 641  : 		if (_Mysb::eback() == &_Mychar)

	mov	edx, DWORD PTR [eax+16]
	lea	ecx, DWORD PTR [eax+72]
	cmp	DWORD PTR [edx], ecx
	jne	SHORT $LN6@Reset_back

; 642  : 			_Mysb::setg(_Set_eback, _Set_egptr, _Set_egptr);

	mov	ecx, DWORD PTR [eax+64]
	push	esi
	mov	esi, DWORD PTR [eax+60]
	mov	DWORD PTR [edx], esi
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR [eax+48]
	sub	ecx, ecx
	mov	DWORD PTR [eax], ecx
	pop	esi
$LN6@Reset_back:

; 643  : 		}

	ret	0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z
_TEXT	SEGMENT
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = esi
; __Newpcvt$ = edi

; 629  : 		if (_Newpcvt->always_noconv())

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, edi
	call	edx
	test	al, al
	je	SHORT $LN2@Initcvt

; 630  : 			_Pcvt = 0;	// nothing to do

	mov	DWORD PTR [esi+68], 0

; 635  : 			}
; 636  : 		}

	ret	0
$LN2@Initcvt:

; 631  : 		else
; 632  : 			{	// set up for nontrivial codecvt facet
; 633  : 			_Pcvt = _Newpcvt;
; 634  : 			_Mysb::_Init();	// reset any buffering

	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], eax
	lea	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+32], ecx
	lea	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+36], edx
	mov	DWORD PTR [esi+68], edi
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+20], eax
	lea	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+48], ecx
	lea	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+52], edx
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], 0

; 635  : 			}
; 636  : 		}

	ret	0
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA DD 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_BSS	ENDS
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Which$ = 8						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = eax
; __File$ = ecx

; 555  : 		{	// initialize to C stream _File after {new, open, close}

	push	ebp
	mov	ebp, esp

; 556  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 557  : 
; 558  : 		_Closef = _Which == _Openfl;

	cmp	DWORD PTR __Which$[ebp], 1
	push	esi

; 559  : 		_Wrotesome = false;
; 560  : 
; 561  : 		_Mysb::_Init();	// initialize stream buffer base object

	lea	esi, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+32], esi
	sete	dl
	mov	BYTE PTR [eax+80], dl
	lea	esi, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+36], esi
	lea	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+16], edx
	lea	esi, DWORD PTR [eax+40]
	mov	DWORD PTR [eax+48], esi
	mov	BYTE PTR [eax+73], 0
	lea	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+20], edx
	lea	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+52], esi
	mov	DWORD PTR [edx], 0
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx], 0
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx], 0
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx], 0
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx], 0
	mov	edx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx], 0
	pop	esi

; 562  : 
; 563  :  #ifndef _IORCNT
; 564  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 565  :   #define _IOWCNT _IOCNT
; 566  :  #endif /* _IORCNT */
; 567  : 
; 568  :   #pragma warning(push)
; 569  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 570  : 		if (_File != 0 && sizeof (_Elem) == 1)

	test	ecx, ecx
	je	SHORT $LN10@Init

; 571  :   #pragma warning(pop)
; 572  : 
; 573  : 			{	// point inside C stream with [first, first + count) buffer
; 574  : 			_Elem **_Pb = (_Elem **)&_File->_IOBASE;

	lea	edx, DWORD PTR [ecx+8]

; 575  : 			_Elem **_Pn = (_Elem **)&_File->_IOPTR;
; 576  : 			int *_Nr = (int *)&_File->_IORCNT;
; 577  : 			int *_Nw = (int *)&_File->_IOWCNT;
; 578  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], edx
	lea	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+48], edx
	mov	DWORD PTR [eax+52], edx
$LN10@Init:

; 579  : 			}
; 580  : 
; 581  : 		_Myfile = _File;

	mov	DWORD PTR [eax+84], ecx

; 582  : 		_State = _Stinit;

	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	DWORD PTR [eax+76], ecx

; 583  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	DWORD PTR [eax+68], 0

; 584  : 		}

	pop	ebp
	ret	4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sbumpc
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN3@sbumpc
	mov	eax, edx
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]

; 148  : 		}

	ret	0
$LN3@sbumpc:

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+28]
	jmp	edx
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = esi
; __Istr$ = eax

; 76   : 			{	// lock the stream buffer, if there

	mov	DWORD PTR [esi], eax

; 77   : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 78   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN8@Sentry_bas:

; 79   : 			}

	mov	eax, esi
	ret	0
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = eax

; 167  : 	__CLR_OR_THIS_CALL basic_ios()

	mov	DWORD PTR [eax], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@

; 168  : 		{	// default constructor, do nothing
; 169  : 		}

	ret	0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1988 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 1989 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN9@Tidy@3

; 1990 : 			;
; 1991 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN9@Tidy@3

; 1992 : 			{	// copy any leftovers to small buffer and deallocate
; 1993 : 			_Elem *_Ptr = this->_Bx._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 1994 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN7@Tidy@3

; 1995 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@Tidy@3:

; 1996 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN9@Tidy@3:

; 1997 : 			}
; 1998 : 		this->_Myres = this->_BUF_SIZE - 1;
; 1999 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi

; 2000 : 		}

	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 1352 : 		return (_STRING_ITERATOR(_Myptr()));

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN5@begin
	mov	ecx, DWORD PTR [ecx]
$LN5@begin:
	mov	DWORD PTR [eax], ecx

; 1353 : 		}

	ret	0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1109 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1110 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	cmp	eax, ecx
	jae	SHORT $LN3@erase

; 1111 : 			_Xran();	// _Off off end

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN28@erase:
$LN3@erase:

; 1112 : 		if (this->_Mysize - _Off < _Count)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, ecx
	cmp	eax, edi

; 1113 : 			_Count = this->_Mysize - _Off;	// trim _Count

	cmovb	edi, eax

; 1114 : 		if (0 < _Count)

	test	edi, edi
	je	SHORT $LN25@erase

; 1115 : 			{	// move elements down
; 1116 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1117 : 				this->_Mysize - _Off - _Count);

	mov	edx, DWORD PTR [esi+20]
	push	ebx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN11@erase
	mov	ebx, DWORD PTR [esi]
	jmp	SHORT $LN12@erase
$LN11@erase:
	mov	ebx, esi
$LN12@erase:
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN15@erase
	mov	edx, DWORD PTR [esi]
	jmp	SHORT $LN16@erase
$LN15@erase:
	mov	edx, esi
$LN16@erase:
	sub	eax, edi
	add	ebx, ecx
	push	eax
	add	ebx, edi
	add	edx, ecx
	push	ebx
	push	edx
	call	_memmove

; 1118 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	sub	eax, edi

; 1119 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], eax
	pop	ebx
	jb	SHORT $LN23@erase
	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [ecx+eax], 0
	pop	edi

; 1120 : 			}
; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1122 : 		}

	pop	ebp
	ret	8

; 1119 : 			_Eos(_Newsize);

$LN23@erase:
	mov	ecx, esi
	mov	BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1120 : 			}
; 1121 : 		return (*this);

	pop	edi
	mov	eax, esi
	pop	esi

; 1122 : 		}

	pop	ebp
	ret	8
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 543  : 		{	// synchronize C stream with external file

	push	esi
	mov	esi, ecx

; 544  : 		return (_Myfile == 0
; 545  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 546  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

	cmp	DWORD PTR [esi+84], 0
	je	SHORT $LN3@sync
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	push	-1
	call	edx
	cmp	eax, -1
	je	SHORT $LN3@sync
	mov	eax, DWORD PTR [esi+84]
	push	eax
	call	_fflush
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN3@sync
	or	eax, -1
	pop	esi

; 547  : 		}

	ret	0
$LN3@sync:

; 544  : 		return (_Myfile == 0
; 545  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 546  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

	xor	eax, eax
	pop	esi

; 547  : 		}

	ret	0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 530  : 		{	// offer _Buffer to C stream

	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, ecx

; 531  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
; 532  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 533  : 			(size_t)_Count * sizeof (_Elem)) != 0)

	mov	ecx, DWORD PTR [edi+84]
	test	ecx, ecx
	je	SHORT $LN2@setbuf
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	esi
	mov	esi, DWORD PTR __Count$[ebp]
	test	edx, edx
	jne	SHORT $LN6@setbuf
	mov	eax, esi
	or	eax, DWORD PTR __Count$[ebp+4]
	jne	SHORT $LN6@setbuf
	mov	eax, 4
	jmp	SHORT $LN7@setbuf
$LN6@setbuf:
	xor	eax, eax
$LN7@setbuf:
	push	esi
	push	eax
	push	edx
	push	ecx
	call	_setvbuf
	add	esp, 16					; 00000010H
	pop	esi
	test	eax, eax
	jne	SHORT $LN2@setbuf

; 535  : 		else
; 536  : 			{	// new buffer, reinitialize pointers
; 537  : 			_Init(_Myfile, _Openfl);

	mov	ecx, DWORD PTR [edi+84]
	push	1
	mov	eax, edi
	call	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 538  : 			return (this);

	mov	eax, edi
	pop	edi

; 539  : 			}
; 540  : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@setbuf:

; 534  : 			return (0);	// failed

	xor	eax, eax
	pop	edi

; 539  : 			}
; 540  : 		}

	pop	ebp
	ret	12					; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 408  : 		{	// get an element from stream, but don't point past it

	push	esi
	mov	esi, ecx

; 409  : 		int_type _Meta;
; 410  : 		if (_Mysb::gptr() != 0
; 411  : 			&& _Mysb::gptr() < _Mysb::egptr())

	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@underflow
	mov	edx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [edx]
	mov	eax, ecx
	add	edx, eax
	cmp	eax, edx
	jae	SHORT $LN4@underflow

; 412  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

	movzx	eax, BYTE PTR [ecx]
	pop	esi

; 419  : 			}
; 420  : 		}

	ret	0
$LN4@underflow:

; 413  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+28]
	push	edi
	mov	ecx, esi
	call	edx
	mov	edi, eax
	cmp	edi, -1
	jne	SHORT $LN2@underflow

; 414  : 			return (_Meta);	// uflow failed, return EOF

	pop	edi
	or	eax, eax
	pop	esi

; 419  : 			}
; 420  : 		}

	ret	0
$LN2@underflow:

; 415  : 		else
; 416  : 			{	// get a char, don't point past it
; 417  : 			pbackfail(_Meta);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	push	edi
	mov	ecx, esi
	call	edx

; 418  : 			return (_Meta);

	mov	eax, edi
	pop	edi
	pop	esi

; 419  : 			}
; 420  : 		}

	ret	0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 383  : 		{	// put an element back to stream

	push	ebp
	mov	ebp, esp
	push	ebx

; 384  : 		if (_Mysb::gptr() != 0
; 385  : 			&& _Mysb::eback() < _Mysb::gptr()
; 386  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
; 387  : 			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
; 388  : 				_Meta)))

	mov	ebx, DWORD PTR __Meta$[ebp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN10@pbackfail
	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [ecx], eax
	jae	SHORT $LN10@pbackfail
	cmp	ebx, -1
	je	SHORT $LN9@pbackfail
	movzx	edx, BYTE PTR [eax-1]
	cmp	edx, ebx
	jne	SHORT $LN10@pbackfail
$LN9@pbackfail:

; 389  : 			{	// just back up position
; 390  : 			_Mysb::_Gndec();

	mov	eax, DWORD PTR [esi+48]
	inc	DWORD PTR [eax]
	mov	esi, DWORD PTR [esi+32]
	dec	DWORD PTR [esi]

; 391  : 			return (_Traits::not_eof(_Meta));

	lea	eax, DWORD PTR [ebx+1]
	neg	eax
	sbb	eax, eax
	pop	esi
	and	eax, ebx
	pop	ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

	pop	ebp
	ret	4
$LN10@pbackfail:

; 392  : 			}
; 393  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN6@pbackfail
	cmp	ebx, -1
	je	SHORT $LN6@pbackfail

; 395  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

	cmp	DWORD PTR [esi+68], 0
	jne	SHORT $LN4@pbackfail
	push	eax
	movzx	eax, bl
	push	eax
	call	_ungetc
	add	esp, 8
	cmp	eax, -1

; 396  : 			return (_Meta);	// no facet and unget succeeded, return

	jne	SHORT $LN55@pbackfail
$LN4@pbackfail:

; 397  : 		else if (_Mysb::gptr() != &_Mychar)

	mov	ecx, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [esi+72]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN6@pbackfail

; 398  : 			{	// putback to _Mychar
; 399  : 			_Mychar = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [eax], bl

; 400  : 			_Set_back();	// switch to _Mychar buffer

	mov	eax, esi
	call	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
$LN55@pbackfail:

; 401  : 			return (_Meta);

	pop	esi
	mov	eax, ebx
	pop	ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

	pop	ebp
	ret	4
$LN6@pbackfail:
	pop	esi

; 394  : 			return (_Traits::eof());	// no open C stream or EOF, fail

	or	eax, -1
	pop	ebx

; 402  : 			}
; 403  : 		else
; 404  : 			return (_Traits::eof());	// nowhere to put back
; 405  : 		}

	pop	ebp
	ret	4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the object

	mov	eax, DWORD PTR [ecx-24]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@

; 964  : 		}

	mov	eax, DWORD PTR [ecx-8]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [ecx-24]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	ret	0
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Copied$ = -8						; size = 8
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 393  : 		{	// put _Count characters to stream

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 394  : 		streamsize _Size, _Copied;
; 395  : 
; 396  : 		for (_Copied = 0; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp+4], 0
	push	ebx
	push	esi
	xorpd	xmm0, xmm0
	push	edi
	mov	ebx, ecx
	movlpd	QWORD PTR __Copied$[esp+24], xmm0
	jl	$LN27@xsputn
	jg	SHORT $LL7@xsputn
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	$LN27@xsputn
	npad	2
$LL7@xsputn:

; 397  : 			if (0 < (_Size = _Pnavail()))

	mov	eax, ebx
	call	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
	mov	edi, edx
	mov	esi, eax
	test	edi, edi
	jl	SHORT $LN5@xsputn
	jg	SHORT $LN25@xsputn
	test	esi, esi
	je	SHORT $LN5@xsputn
$LN25@xsputn:

; 398  : 				{	// copy to write buffer
; 399  : 				if (_Count < _Size)

	mov	eax, DWORD PTR __Count$[ebp+4]
	cmp	eax, edi
	jg	SHORT $LN4@xsputn
	jl	SHORT $LN26@xsputn
	cmp	DWORD PTR __Count$[ebp], esi
	jae	SHORT $LN4@xsputn
$LN26@xsputn:

; 400  : 					_Size = _Count;

	mov	esi, DWORD PTR __Count$[ebp]
	mov	edi, eax
$LN4@xsputn:

; 401  : 				_Traits::copy(pptr(), _Ptr, (size_t)_Size);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [ebx+36]
	mov	edx, DWORD PTR [ecx]
	push	esi
	push	eax
	push	edx
	call	_memcpy

; 402  : 				_Ptr += _Size;

	add	DWORD PTR __Ptr$[ebp], esi

; 403  : 				_Copied += _Size;
; 404  : 				_Count -= _Size;
; 405  : 				pbump((int)_Size);

	mov	eax, DWORD PTR [ebx+52]
	add	esp, 12					; 0000000cH
	add	DWORD PTR __Copied$[esp+24], esi
	adc	DWORD PTR __Copied$[esp+28], edi
	sub	DWORD PTR __Count$[ebp], esi
	sbb	DWORD PTR __Count$[ebp+4], edi
	sub	DWORD PTR [eax], esi
	mov	eax, DWORD PTR [ebx+36]
	add	DWORD PTR [eax], esi

; 406  : 				}
; 407  : 			else if (_Traits::eq_int_type(_Traits::eof(),

	jmp	SHORT $LN1@xsputn
$LN5@xsputn:

; 408  : 				overflow(_Traits::to_int_type(*_Ptr))))

	mov	eax, DWORD PTR __Ptr$[ebp]
	movzx	eax, BYTE PTR [eax]
	mov	edx, DWORD PTR [ebx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, ebx
	call	eax
	or	ecx, -1
	cmp	eax, ecx
	je	SHORT $LN27@xsputn

; 409  : 				break;	// single character put failed, quit
; 410  : 			else
; 411  : 				{	// count character successfully put
; 412  : 				++_Ptr;

	mov	eax, 1
	add	DWORD PTR __Ptr$[ebp], eax

; 413  : 				++_Copied;

	add	DWORD PTR __Copied$[esp+24], eax
	adc	DWORD PTR __Copied$[esp+28], 0

; 414  : 				--_Count;

	add	DWORD PTR __Count$[ebp], ecx
	adc	DWORD PTR __Count$[ebp+4], ecx
$LN1@xsputn:

; 394  : 		streamsize _Size, _Copied;
; 395  : 
; 396  : 		for (_Copied = 0; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp+4], 0
	jg	$LL7@xsputn
	jl	SHORT $LN27@xsputn
	cmp	DWORD PTR __Count$[ebp], 0
	ja	$LL7@xsputn
$LN27@xsputn:

; 415  : 				}
; 416  : 
; 417  : 		return (_Copied);

	mov	eax, DWORD PTR __Copied$[esp+24]
	mov	edx, DWORD PTR __Copied$[esp+28]

; 418  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
__Copied$ = -8						; size = 8
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 364  : 		{	// get _Count characters from stream

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 365  : 		int_type _Meta;
; 366  : 		streamsize _Size, _Copied;
; 367  : 
; 368  : 		for (_Copied = 0; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp+4], 0
	push	ebx
	push	esi
	xorpd	xmm0, xmm0
	push	edi
	mov	ebx, ecx
	movlpd	QWORD PTR __Copied$[esp+24], xmm0
	jl	$LN27@xsgetn
	jg	SHORT $LL7@xsgetn
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	$LN27@xsgetn
	npad	2
$LL7@xsgetn:

; 369  : 			if (0 < (_Size = _Gnavail()))

	mov	eax, ebx
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	mov	edi, edx
	mov	esi, eax
	test	edi, edi
	jl	SHORT $LN5@xsgetn
	jg	SHORT $LN25@xsgetn
	test	esi, esi
	je	SHORT $LN5@xsgetn
$LN25@xsgetn:

; 370  : 				{	// copy from read buffer
; 371  : 				if (_Count < _Size)

	mov	eax, DWORD PTR __Count$[ebp+4]
	cmp	eax, edi
	jg	SHORT $LN4@xsgetn
	jl	SHORT $LN26@xsgetn
	cmp	DWORD PTR __Count$[ebp], esi
	jae	SHORT $LN4@xsgetn
$LN26@xsgetn:

; 372  : 					_Size = _Count;

	mov	esi, DWORD PTR __Count$[ebp]
	mov	edi, eax
$LN4@xsgetn:

; 373  : 				_Traits::copy(_Ptr, gptr(), (size_t)_Size);

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	push	ecx
	push	edx
	call	_memcpy

; 374  : 				_Ptr += _Size;

	add	DWORD PTR __Ptr$[ebp], esi

; 375  : 				_Copied += _Size;
; 376  : 				_Count -= _Size;
; 377  : 				gbump((int)_Size);

	mov	eax, DWORD PTR [ebx+48]
	add	esp, 12					; 0000000cH
	add	DWORD PTR __Copied$[esp+24], esi
	adc	DWORD PTR __Copied$[esp+28], edi
	sub	DWORD PTR __Count$[ebp], esi
	sbb	DWORD PTR __Count$[ebp+4], edi
	sub	DWORD PTR [eax], esi
	mov	eax, DWORD PTR [ebx+32]
	add	DWORD PTR [eax], esi
	jmp	SHORT $LN1@xsgetn
$LN5@xsgetn:

; 378  : 				}
; 379  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+28]
	mov	ecx, ebx
	call	edx
	or	edx, -1
	cmp	eax, edx
	je	SHORT $LN27@xsgetn

; 380  : 				break;	// end of file, quit
; 381  : 			else
; 382  : 				{	// get a single character
; 383  : 				*_Ptr++ = _Traits::to_char_type(_Meta);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	inc	ecx

; 384  : 				++_Copied;

	add	DWORD PTR __Copied$[esp+24], 1
	mov	BYTE PTR [ecx-1], al
	mov	DWORD PTR __Ptr$[ebp], ecx
	adc	DWORD PTR __Copied$[esp+28], 0

; 385  : 				--_Count;

	add	DWORD PTR __Count$[ebp], edx
	adc	DWORD PTR __Count$[ebp+4], edx
$LN1@xsgetn:

; 365  : 		int_type _Meta;
; 366  : 		streamsize _Size, _Copied;
; 367  : 
; 368  : 		for (_Copied = 0; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp+4], 0
	jg	$LL7@xsgetn
	jl	SHORT $LN27@xsgetn
	cmp	DWORD PTR __Count$[ebp], 0
	ja	$LL7@xsgetn
$LN27@xsgetn:

; 386  : 				}
; 387  : 
; 388  : 		return (_Copied);

	mov	eax, DWORD PTR __Copied$[esp+24]
	mov	edx, DWORD PTR __Copied$[esp+28]

; 389  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 357  : 		{	// get a character from stream, point past it

	push	esi
	mov	esi, ecx

; 358  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 359  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	cmp	eax, -1
	jne	SHORT $LN3@uflow
	or	eax, eax
	pop	esi

; 360  : 		}

	ret	0
$LN3@uflow:

; 358  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 359  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

	mov	eax, DWORD PTR [esi+48]
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
	movzx	eax, BYTE PTR [ecx]
	pop	esi

; 360  : 		}

	ret	0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 353  : 		return (_Traits::eof());

	or	eax, -1

; 354  : 		}

	ret	0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 343  : 		return (_Traits::eof());

	or	eax, -1

; 344  : 		}

	ret	4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 338  : 		return (_Traits::eof());

	or	eax, -1

; 339  : 		}

	ret	4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sgetc
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN3@sgetc
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]

; 154  : 		}

	ret	0
$LN3@sgetc:

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	jmp	eax
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = eax

; 83   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+56]
	test	eax, eax
	je	SHORT $LN1@Sentry_bas@2

; 84   : 				_Myistr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	jmp	eax
$LN1@Sentry_bas@2:

; 85   : 			}

	ret	0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 38   : 		}

	push	ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	pop	ecx
	ret	0
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 753  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 754  : 		_Tidy(true);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN11@basic_stri
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@basic_stri:
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0
	pop	esi

; 755  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax

; 551  : 		_Tidy();

	mov	DWORD PTR [eax+20], 15			; 0000000fH
	mov	DWORD PTR [eax+16], 0
	mov	BYTE PTR [eax], 0

; 552  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?cl_release_all@@YAXXZ				; cl_release_all
; Function compile flags: /Ogtp
; File c:\users\tdrol\documents\visual studio 2010\projects\analizator\analizator-bd-opencl\cl_encrypt.cpp
;	COMDAT ?cl_release_all@@YAXXZ
_TEXT	SEGMENT
?cl_release_all@@YAXXZ PROC				; cl_release_all, COMDAT

; 215  : 	cl_release_kernel();

	mov	eax, DWORD PTR _state
	push	esi
	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR __imp__clReleaseMemObject@4
	cmp	eax, esi
	je	SHORT $LN8@cl_release@2
	push	eax
	call	edi
	mov	DWORD PTR _state, esi
$LN8@cl_release@2:
	mov	eax, DWORD PTR _roundkeys
	cmp	eax, esi
	je	SHORT $LN7@cl_release@2
	push	eax
	call	edi
	mov	DWORD PTR _roundkeys, esi
$LN7@cl_release@2:
	mov	eax, DWORD PTR _kernel
	cmp	eax, esi
	je	SHORT $LN6@cl_release@2
	push	eax
	call	DWORD PTR __imp__clReleaseKernel@4
	mov	DWORD PTR _kernel, esi
$LN6@cl_release@2:

; 216  : 
; 217  : 	if (program != nullptr)

	mov	eax, DWORD PTR _program
	cmp	eax, esi
	je	SHORT $LN3@cl_release@2

; 218  : 	{
; 219  : 		clReleaseProgram(program);

	push	eax
	call	DWORD PTR __imp__clReleaseProgram@4

; 220  : 		program = nullptr;

	mov	DWORD PTR _program, esi
$LN3@cl_release@2:

; 221  : 	}
; 222  : 
; 223  : 	if (queue != nullptr)

	mov	eax, DWORD PTR _queue
	cmp	eax, esi
	je	SHORT $LN2@cl_release@2

; 224  : 	{
; 225  : 		clReleaseCommandQueue(queue);

	push	eax
	call	DWORD PTR __imp__clReleaseCommandQueue@4

; 226  : 		queue = nullptr;

	mov	DWORD PTR _queue, esi
$LN2@cl_release@2:

; 227  : 	}
; 228  : 
; 229  : 	if (context != nullptr)

	mov	eax, DWORD PTR _context
	cmp	eax, esi
	je	SHORT $LN1@cl_release@2

; 230  : 	{
; 231  : 		clReleaseContext(context);

	push	eax
	call	DWORD PTR __imp__clReleaseContext@4

; 232  : 		context = nullptr;

	mov	DWORD PTR _context, esi
$LN1@cl_release@2:

; 233  : 
; 234  : 	}
; 235  : }

	pop	edi
	pop	esi
	ret	0
?cl_release_all@@YAXXZ ENDP				; cl_release_all
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+56]
	test	eax, eax
	je	SHORT $LN4@sentry
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	jmp	eax
$LN4@sentry:
	ret	0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[ebp]
	push	edi
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	pop	edi
	mov	DWORD PTR [esi+16], ecx
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = eax

; 368  : 		return (((int)rdstate()
; 369  : 			& ((int)badbit | (int)failbit)) != 0);

	test	BYTE PTR [eax+12], 6
	mov	eax, 0
	setne	al

; 370  : 		}

	ret	0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 358  : 		return (rdstate() == goodbit);

	xor	eax, eax
	cmp	DWORD PTR [ecx+12], eax
	sete	al

; 359  : 		}

	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN10@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@3:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
_TEXT	ENDS
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
$T30898 = -4						; size = 4
__Errcode$ = 8						; size = 8
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = esi
; __Message$ = eax

; 516  : 		{	// construct from error code and message string

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	ecx, DWORD PTR $T30898[ebp]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T30898[ebp], eax
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	eax, DWORD PTR __Errcode$[ebp+4]
	mov	edx, DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
	mov	DWORD PTR [esi+12], edx

; 517  : 		_Makestr();
; 518  : 		}

	mov	eax, esi
	mov	esp, ebp
	pop	ebp
	ret	8
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z
_TEXT	SEGMENT
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z PROC ; std::make_error_code, COMDAT
; ___$ReturnUdt$ = esi

; 447  : 	return (error_code(_Errno, iostream_category()));

	call	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], 1
	mov	eax, esi

; 448  : 	}

	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z ENDP ; std::make_error_code
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T30917 = -16						; size = 16
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = esi

; 2399 : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp

; 2400 : 		_Ctype = _Lobj._Getctype();

	lea	eax, DWORD PTR $T30917[ebp]
	sub	esp, 16					; 00000010H
	push	eax
	call	__Getctype
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [esi+8], xmm0
	movq	xmm0, QWORD PTR [eax+8]
	add	esp, 4
	movq	QWORD PTR [esi+16], xmm0

; 2401 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = eax

; 2016 : 		}

	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = eax

; 2011 : 		{	// default constructor

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 2012 : 		}

	ret	0
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT
??1codecvt_base@std@@UAE@XZ PROC			; std::codecvt_base::~codecvt_base, COMDAT
; _this$ = eax

; 772  : 		}

	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1codecvt_base@std@@UAE@XZ ENDP			; std::codecvt_base::~codecvt_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT
??0codecvt_base@std@@QAE@I@Z PROC			; std::codecvt_base::codecvt_base, COMDAT
; _this$ = eax

; 752  : 		{	// default constructor

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], OFFSET ??_7codecvt_base@std@@6B@

; 753  : 		}

	ret	0
??0codecvt_base@std@@QAE@I@Z ENDP			; std::codecvt_base::codecvt_base
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN6@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@4:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$30960 = -4					; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 409  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi

; 410  : 		if (_Ptr != 0)

	mov	edi, DWORD PTR [ecx]
	test	edi, edi
	je	SHORT $LN4@locale

; 411  : 			_DELETE_CRT(_Ptr->_Decref());

	push	0
	lea	ecx, DWORD PTR __Lock$30960[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN6@locale
	cmp	eax, -1
	jae	SHORT $LN6@locale
	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN6@locale:
	push	esi
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	lea	ecx, DWORD PTR __Lock$30960[ebp]
	not	esi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	and	esi, edi
	je	SHORT $LN9@locale
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN9@locale:
	pop	esi
$LN4@locale:
	pop	edi

; 412  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$30969 = -4					; size = 4
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = edi

; 315  : 		{	// construct from current locale

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	call	?_Init@locale@std@@CAPAV_Locimp@12@XZ	; std::locale::_Init
	mov	DWORD PTR [edi], eax

; 316  : 		_Getgloballocale()->_Incref();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	push	0
	lea	ecx, DWORD PTR __Lock$30969[ebp]
	mov	esi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN3@locale@2
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN3@locale@2:
	lea	ecx, DWORD PTR __Lock$30969[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 317  : 		}

	mov	eax, edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Lock$30977 = -4					; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = edi
; __Right$ = eax

; 309  : 		{	// construct by copying

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, DWORD PTR [eax]

; 310  : 		_Ptr->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$30977[ebp]
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN3@locale@3
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN3@locale@3:
	lea	ecx, DWORD PTR __Lock$30977[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 311  : 		}

	mov	eax, edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T30982 = -28						; size = 12
$T31008 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; __Pch$ = edi

; 76   :         {	// construct from NTBS

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Locinfo@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[ebp]
	xor	ebx, ebx
	push	ebx
	mov	ecx, esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR [esi+12], ebx
	mov	BYTE PTR [esi+16], bl
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+24], bl
	mov	DWORD PTR [esi+28], ebx
	mov	BYTE PTR [esi+32], bl
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 77   :         if (_Pch == 0)

	cmp	edi, ebx
	jne	SHORT $LN1@Locinfo@2

; 78   :             _THROW_NCEE(runtime_error, "bad locale name");

	lea	eax, DWORD PTR $T31008[ebp]
	push	eax
	lea	ecx, DWORD PTR $T30982[ebp]
	mov	DWORD PTR $T31008[ebp], OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	ecx, DWORD PTR $T30982[ebp]
	push	ecx
	mov	DWORD PTR $T30982[ebp], OFFSET ??_7runtime_error@std@@6B@
	call	__CxxThrowException@8
$LN22@Locinfo@2:
$LN1@Locinfo@2:

; 79   :         _Locinfo_ctor(this, _Pch);

	push	edi
	push	esi
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 80   :         }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN21@Locinfo@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@5:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z PROC	; std::codecvt<char,char,int>::codecvt<char,char,int>, COMDAT
; _this$ = eax

; 843  : 		{	// construct from specified locale

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], OFFSET ??_7?$codecvt@DDH@std@@6B@

; 844  : 		_Init(_Lobj);
; 845  : 		}

	ret	0
??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z ENDP	; std::codecvt<char,char,int>::codecvt<char,char,int>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T31041 = -52						; size = 36
$T31045 = -16						; size = 4
$T31040 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::codecvt<char,char,int>::_Getcat, COMDAT

; 849  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 850  : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	edi, DWORD PTR __Ppf$[ebp]

; 851  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 852  : 				_Locinfo(_Ploc->c_str()));

	xor	ebx, ebx
	mov	DWORD PTR $T31045[ebp], ebx
	cmp	edi, ebx
	je	SHORT $LN26@Getcat

; 850  : 		if (_Ppf != 0 && *_Ppf == 0)

	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN26@Getcat

; 851  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 852  : 				_Locinfo(_Ploc->c_str()));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T31040[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	cmp	esi, ebx
	je	SHORT $LN4@Getcat
	mov	eax, DWORD PTR __Ploc$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+24]
	cmp	edi, ebx
	jne	SHORT $LN15@Getcat
	lea	edi, DWORD PTR [eax+28]
$LN15@Getcat:
	lea	ecx, DWORD PTR $T31041[ebp]
	push	ecx
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	edi, DWORD PTR __Ppf$[ebp]
	mov	ebx, 1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$codecvt@DDH@std@@6B@
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi], esi
	test	bl, 1
	je	SHORT $LN26@Getcat
	lea	edx, DWORD PTR $T31041[ebp]
	push	edx
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@Getcat:

; 853  : 		return (_X_CTYPE);

	mov	eax, 2

; 854  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T31040[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::codecvt<char,char,int>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T31095 = -36						; size = 12
__Lock$26674 = -24					; size = 4
__Lock$31103 = -20					; size = 4
__Lock$31125 = -20					; size = 4
__Psave$26675 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,int> >, COMDAT
; __Loc$ = edi

; 504  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$26674[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 508  : 
; 509  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, 0 ; std::codecvt<char,char,int>::id
	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
	mov	DWORD PTR __Psave$26675[ebp], ebx
	jne	SHORT $LN11@use_facet
	push	0
	lea	ecx, DWORD PTR __Lock$31103[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, 0 ; std::codecvt<char,char,int>::id
	jne	SHORT $LN10@use_facet
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, eax ; std::codecvt<char,char,int>::id
$LN10@use_facet:
	lea	ecx, DWORD PTR __Lock$31103[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet:
	mov	esi, DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A ; std::codecvt<char,char,int>::id

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR [edi]
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet
	mov	ecx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	jne	SHORT $LN16@use_facet
$LN30@use_facet:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN31@use_facet
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN15@use_facet
$LN20@use_facet:
	xor	ecx, ecx
	jmp	SHORT $LN30@use_facet
$LN16@use_facet:
	mov	esi, ecx
$LN15@use_facet:

; 511  : 
; 512  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN28@use_facet
$LN31@use_facet:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 515  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN28@use_facet
$LN4@use_facet:

; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$26675[ebp]
	push	edi
	push	eax
	call	?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<char,char,int>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T31095[ebp]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	ecx, DWORD PTR $T31095[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN37@use_facet:
$LN2@use_facet:

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$26675[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$31125[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN24@use_facet
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN24@use_facet:
	lea	ecx, DWORD PTR __Lock$31125[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 533  : 			_Pfmod->_Register();

	push	esi
	call	?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
	add	esp, 4
$LN28@use_facet:

; 534  : 			}
; 535  : 
; 536  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$26674[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 537  : 	_END_LOCK()
; 538  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$26674[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T31244 = -40						; size = 12
__Newres$ = -28						; size = 4
$T31222 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1919 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 1920 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	esi, eax
	or	esi, 15					; 0000000fH

; 1921 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN9@Copy

; 1922 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax
	jmp	SHORT $LN39@Copy
$LN9@Copy:

; 1923 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	ebx, DWORD PTR [edi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN39@Copy

; 1924 : 			;
; 1925 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, -2					; fffffffeH
	sub	eax, ecx

; 1926 : 			_Newres = this->_Myres
; 1927 : 				+ this->_Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
	cmp	ebx, eax
	jbe	SHORT $LN39@Copy

; 1928 : 		else
; 1929 : 			_Newres = max_size();	// settle for max_size()

	mov	esi, -2					; fffffffeH
$LN39@Copy:

; 1930 : 
; 1931 : 		_Elem *_Ptr;
; 1932 : 		_TRY_BEGIN

	xor	eax, eax

; 1933 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	cmp	ecx, eax
	jbe	SHORT $LN47@Copy
	cmp	ecx, -1
	ja	SHORT $LN46@Copy
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN46@Copy
$LN47@Copy:
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN19@Copy
$LN46@Copy:
	lea	ecx, DWORD PTR $T31222[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T31244[ebp]
	mov	DWORD PTR $T31222[ebp], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T31244[ebp]
	push	edx
	mov	DWORD PTR $T31244[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN112@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1934 : 		_CATCH_ALL
; 1935 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1936 : 			_TRY_BEGIN
; 1937 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	add	ecx, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1941 : 			_CATCH_END
; 1942 : 		_CATCH_END

	mov	eax, $LN107@Copy
	ret	0
$LN107@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1943 : 
; 1944 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	je	SHORT $LN78@Copy

; 1945 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN76@Copy
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN77@Copy
$LN76@Copy:
	mov	eax, edi
$LN77@Copy:
	push	ebx
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN78@Copy:

; 1946 : 		_Tidy(true);

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN88@Copy
	mov	ecx, DWORD PTR [edi]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN88@Copy:

; 1947 : 		this->_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edi], 0
	mov	DWORD PTR [edi], eax

; 1948 : 		this->_Myres = _Newres;

	mov	DWORD PTR [edi+20], esi

; 1949 : 		_Eos(_Oldlen);

	mov	DWORD PTR [edi+16], ebx
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN102@Copy
	mov	edi, eax
$LN102@Copy:
	mov	BYTE PTR [edi+ebx], 0

; 1950 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1938 : 			_CATCH_ALL
; 1939 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN64@Copy
	mov	edx, DWORD PTR [esi]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN64@Copy:

; 1940 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	push	0
	mov	BYTE PTR [esi], 0
	call	__CxxThrowException@8
$LN113@Copy:
$LN111@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
__Lock$31407 = -4					; size = 4
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::getloc, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 129  : 		{	// get locale

	push	ebp
	mov	ebp, esp
	push	ecx

; 130  : 		return (*_Plocale);

	mov	ecx, DWORD PTR [eax+56]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	0
	lea	ecx, DWORD PTR __Lock$31407[ebp]
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN5@getloc
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN5@getloc:
	lea	ecx, DWORD PTR __Lock$31407[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, edi
	pop	esi

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::getloc
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
__Lock$31428 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT

; 25   : 		{	// construct with no buffers

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	call	??0_Mutex@std@@QAE@XZ			; std::_Mutex::_Mutex
	push	4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN3@basic_stre
	call	?_Init@locale@std@@CAPAV_Locimp@12@XZ	; std::locale::_Init
	mov	DWORD PTR [edi], eax
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	push	0
	lea	ecx, DWORD PTR __Lock$31428[ebp]
	mov	ebx, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, -1
	jae	SHORT $LN8@basic_stre
	inc	eax
	mov	DWORD PTR [ebx+4], eax
$LN8@basic_stre:
	lea	ecx, DWORD PTR __Lock$31428[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	jmp	SHORT $LN4@basic_stre
$LN3@basic_stre:
	xor	edi, edi
$LN4@basic_stre:

; 26   : 		_Init();

	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], eax
	lea	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+32], ecx
	lea	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+36], edx
	mov	DWORD PTR [esi+56], edi
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+20], eax
	lea	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+48], ecx
	lea	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+52], edx
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], 0

; 27   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T31454 = 8						; size = 4
_this$ = 8						; size = 4
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >, COMDAT

; 54   : 	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T31454[ebp], 0
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+edx], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 55   : 		{	// construct uninitialized
; 56   : 		if (_Addit)
; 57   : 			ios_base::_Addstd(this);	// suppress for basic_iostream
; 58   : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1959 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	ebx

; 1960 : 		if (max_size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[ebp]
	push	esi
	mov	esi, ecx
	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN6@Grow

; 1961 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN49@Grow:
$LN6@Grow:

; 1962 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	jae	SHORT $LN5@Grow

; 1963 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	ebx
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 1970 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 1964 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN3@Grow
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN3@Grow

; 1965 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1966 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	ebx, edi
	jae	SHORT $LN9@Grow
	mov	edi, ebx
$LN9@Grow:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN30@Grow
	mov	ebx, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN28@Grow
	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN28@Grow:
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	ebx, DWORD PTR __Newsize$[ebp]
	add	esp, 4
$LN30@Grow:
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	mov	BYTE PTR [edi+esi], 0
	cmp	ecx, ebx
	pop	edi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 1970 : 		}

	pop	ebp
	ret	8
$LN3@Grow:

; 1967 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN46@Grow

; 1968 : 			_Eos(0);	// new size is zero, just null terminate

	mov	DWORD PTR [esi+16], ebx
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN44@Grow
	mov	esi, DWORD PTR [esi]
$LN44@Grow:
	mov	BYTE PTR [esi], 0
$LN46@Grow:

; 1969 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 1970 : 		}

	pop	ebp
	ret	8
$LN48@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = esi

; 936  : 		if (_Count == npos)
; 937  : 			_Xlen();	// result too long
; 938  : 
; 939  : 		if (_Grow(_Count))

	cmp	DWORD PTR [esi+20], 8
	jae	SHORT $LN12@assign
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	8
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN12@assign:

; 940  : 			{	// make room and assign new stuff
; 941  : 			_Chassign(0, _Count, _Ch);

	mov	ecx, 16					; 00000010H
	cmp	DWORD PTR [esi+20], ecx
	jb	SHORT $LN67@assign
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN68@assign
$LN67@assign:
	mov	eax, esi
$LN68@assign:
	pxor	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0

; 942  : 			_Eos(_Count);

	mov	DWORD PTR [esi+16], 8
	cmp	DWORD PTR [esi+20], ecx
	jb	SHORT $LN75@assign
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+8], 0

; 943  : 			}
; 944  : 		return (*this);

	mov	eax, esi

; 945  : 		}

	ret	0

; 942  : 			_Eos(_Count);

$LN75@assign:
	mov	BYTE PTR [esi+8], 0

; 943  : 			}
; 944  : 		return (*this);

	mov	eax, esi

; 945  : 		}

	ret	0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??1?$codecvt@DDH@std@@MAE@XZ
_TEXT	SEGMENT
??1?$codecvt@DDH@std@@MAE@XZ PROC			; std::codecvt<char,char,int>::~codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 859  : 		}

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1?$codecvt@DDH@std@@MAE@XZ ENDP			; std::codecvt<char,char,int>::~codecvt<char,char,int>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
__Lock$31831 = -20					; size = 4
$T31807 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 218  : 		{	// open a C stream with specified mode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 219  : 		_Filet *_File;
; 220  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

	cmp	DWORD PTR [esi+84], 0
	jne	$LN1@open
	push	64					; 00000040H
	push	1
	push	OFFSET ??_C@_0BB@GKNLBPKG@?4?1aes?9encrypt?4cl?$AA@
	call	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z	; std::_Fiopen
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@open

; 222  : 
; 223  : 		_Init(_File, _Openfl);

	mov	ecx, eax
	push	1
	mov	eax, esi
	call	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 224  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

	lea	edi, DWORD PTR $T31807[ebp]
	mov	eax, esi
	call	?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
	mov	edi, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
	mov	edi, eax
	call	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ebx, DWORD PTR $T31807[ebp]
	test	ebx, ebx
	je	SHORT $LN9@open
	push	0
	lea	ecx, DWORD PTR __Lock$31831[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN11@open
	cmp	eax, -1
	jae	SHORT $LN11@open
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN11@open:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	lea	ecx, DWORD PTR __Lock$31831[ebp]
	not	edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	and	edi, ebx
	je	SHORT $LN9@open
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, edi
	call	edx
$LN9@open:

; 225  : 		return (this);	// open succeeded

	mov	eax, esi

; 226  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@open:

; 221  : 			return (0);	// open failed

	xor	eax, eax

; 226  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
	lea	ecx, DWORD PTR $T31807[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = esi

; 845  : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp

; 846  : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR [esi+16]
	or	ecx, -1
	push	ebx
	mov	ebx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	cmp	ecx, ebx
	ja	SHORT $LN2@append

; 847  : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN83@append:
$LN2@append:

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	test	ebx, ebx
	je	$LN77@append
	push	edi
	lea	edi, DWORD PTR [eax+ebx]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN13@append
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN84@append:
$LN13@append:
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, edi
	jae	SHORT $LN12@append
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
	je	$LN79@append
$LN82@append:

; 851  : 			{	// make room and append new stuff using assign
; 852  : 			_Chassign(this->_Mysize, _Count, _Ch);

	mov	ecx, DWORD PTR [esi+16]
	cmp	ebx, 1
	jne	SHORT $LN56@append
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN61@append
	mov	eax, DWORD PTR [esi]
	mov	dl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax+ecx], dl
	jmp	SHORT $LN69@append

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

$LN12@append:
	test	edi, edi
	jne	SHORT $LN82@append
	mov	DWORD PTR [esi+16], edi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN51@append
	mov	eax, DWORD PTR [esi]
	pop	edi
	mov	BYTE PTR [eax], 0

; 854  : 			}
; 855  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 856  : 		}

	pop	ebp
	ret	8

; 848  : 
; 849  : 		size_type _Num;
; 850  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

$LN51@append:
	mov	eax, esi
	pop	edi
	mov	BYTE PTR [eax], 0
	pop	ebx

; 856  : 		}

	pop	ebp
	ret	8

; 851  : 			{	// make room and append new stuff using assign
; 852  : 			_Chassign(this->_Mysize, _Count, _Ch);

$LN61@append:
	mov	dl, BYTE PTR __Ch$[ebp]
	mov	eax, esi
	mov	BYTE PTR [eax+ecx], dl
	jmp	SHORT $LN69@append
$LN56@append:
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN67@append
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN68@append
$LN67@append:
	mov	eax, esi
$LN68@append:
	movsx	edx, BYTE PTR __Ch$[ebp]
	push	ebx
	push	edx
	add	eax, ecx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN69@append:

; 853  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN75@append
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 854  : 			}
; 855  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 856  : 		}

	pop	ebp
	ret	8

; 853  : 			_Eos(_Num);

$LN75@append:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN79@append:
	pop	edi
$LN77@append:

; 854  : 			}
; 855  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 856  : 		}

	pop	ebp
	ret	8
$LN80@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = esi

; 607  : 		_Tidy();

	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0

; 608  : 		assign(_Count, _Ch);

	cmp	DWORD PTR [esi+20], 8
	jae	SHORT $LN38@basic_stri@2
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	8
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN38@basic_stri@2:
	mov	ecx, 16					; 00000010H
	cmp	DWORD PTR [esi+20], ecx
	jb	SHORT $LN93@basic_stri@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN94@basic_stri@2
$LN93@basic_stri@2:
	mov	eax, esi
$LN94@basic_stri@2:
	pxor	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [esi+16], 8
	cmp	DWORD PTR [esi+20], ecx
	jb	SHORT $LN101@basic_stri@2
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+8], 0

; 609  : 		}

	mov	eax, esi
	ret	0

; 608  : 		assign(_Count, _Ch);

$LN101@basic_stri@2:
	mov	BYTE PTR [esi+8], 0

; 609  : 		}

	mov	eax, esi
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	add	eax, 24					; 00000018H
	mov	DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR [eax-8]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR [eax-24]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	pop	ecx
	ret	0
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	add	eax, 16					; 00000010H
	mov	DWORD PTR [edx+eax-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	pop	ecx
	ret	0
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	add	eax, 8
	mov	DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	pop	ecx
	ret	0
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	lea	esi, DWORD PTR [ecx-24]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR [eax-8]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR [eax-24]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN17@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@scalar@6:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
__Lock$32561 = -4					; size = 4
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC				; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN7@scalar@7
	push	0
	lea	ecx, DWORD PTR __Lock$32561[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN9@scalar@7
	cmp	eax, -1
	jae	SHORT $LN9@scalar@7
	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN9@scalar@7:
	push	esi
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	lea	ecx, DWORD PTR __Lock$32561[ebp]
	not	esi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	and	esi, edi
	je	SHORT $LN13@scalar@7
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN13@scalar@7:
	pop	esi
$LN7@scalar@7:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar@7
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@scalar@7:
	pop	edi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	lea	esi, DWORD PTR [ecx-16]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+eax-16], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@8:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar@9
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@9:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	lea	esi, DWORD PTR [ecx-8]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar@10
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@10:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 550  : 		{	// set locale to argument (capture nontrivial codecvt facet)

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 551  : 		_Initcvt(&_USE(_Loc, _Cvt));

	mov	edi, DWORD PTR __Loc$[ebp]
	mov	esi, ecx
	call	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
	mov	edi, eax
	call	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPBV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
	pop	edi
	pop	esi

; 552  : 		}

	pop	ebp
	ret	4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
__Dest$25484 = -60					; size = 4
$T33123 = -56						; size = 4
__Src$25485 = -52					; size = 4
__Ch$25483 = -45					; size = 1
__Str$25479 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 423  : 		{	// get an element from stream, point past it

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 424  : 		if (_Mysb::gptr() != 0
; 425  : 			&& _Mysb::gptr() < _Mysb::egptr())

	mov	eax, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [eax]
	xor	edx, edx
	cmp	eax, edx
	je	SHORT $LN18@uflow@2
	mov	ecx, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	cmp	eax, ecx
	jae	SHORT $LN18@uflow@2

; 426  : 			return (_Traits::to_int_type(
; 427  : 				*_Mysb::_Gninc()));	// return buffered

	mov	eax, DWORD PTR [edi+48]
	dec	DWORD PTR [eax]
	mov	edi, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [edi], edx
	movzx	eax, BYTE PTR [eax]
	jmp	$LN14@uflow@2
$LN18@uflow@2:

; 428  : 		else if (_Myfile == 0)

	cmp	DWORD PTR [edi+84], edx

; 429  : 			return (_Traits::eof());	// no open C stream, fail

	je	$LN262@uflow@2

; 430  : 		_Reset_back();	// revert from _Mychar buffer

	mov	ecx, DWORD PTR [edi+16]
	lea	esi, DWORD PTR [edi+72]
	cmp	DWORD PTR [ecx], esi
	jne	SHORT $LN41@uflow@2
	mov	eax, DWORD PTR [edi+64]
	mov	esi, DWORD PTR [edi+60]
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR [edi+48]
	sub	eax, eax
	mov	DWORD PTR [ecx], eax
$LN41@uflow@2:

; 431  : 		if (_Pcvt == 0)

	cmp	DWORD PTR [edi+68], edx
	jne	SHORT $LN15@uflow@2

; 432  : 			{	// no codecvt facet, just get it
; 433  : 			_Elem _Ch = 0;
; 434  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
; 435  : 				: _Traits::eof());

	mov	edi, DWORD PTR [edi+84]
	push	edi
	call	_fgetc
	add	esp, 4
	cmp	eax, -1
	je	$LN262@uflow@2
	movzx	eax, al
	jmp	$LN14@uflow@2
$LN15@uflow@2:

; 436  : 			}
; 437  : 		else
; 438  : 			{	// build string until codecvt succeeds
; 439  : 			string _Str;

	mov	DWORD PTR __Str$25479[ebp+20], 15	; 0000000fH
	mov	DWORD PTR __Str$25479[ebp+16], edx
	mov	BYTE PTR __Str$25479[ebp], dl
	mov	DWORD PTR __$EHRec$[ebp+8], edx

; 440  : 
; 441  : 			for (; ; )
; 442  : 				{	// get using codecvt facet
; 443  : 				_Elem _Ch, *_Dest;
; 444  : 				const char *_Src;
; 445  : 				int _Nleft;
; 446  : 				int _Meta = fgetc(_Myfile);

	mov	edx, DWORD PTR [edi+84]
	push	edx
	call	_fgetc
	mov	ebx, eax
	add	esp, 4

; 447  : 
; 448  : 				if (_Meta == EOF)

	cmp	ebx, -1
	je	$LN276@uflow@2
	npad	1
$LL13@uflow@2:

; 450  : 
; 451  : 				_Str.append(1, (char)_Meta);	// append byte and convert

	mov	eax, DWORD PTR __Str$25479[ebp+16]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, 1
	jbe	$LN277@uflow@2
	lea	esi, DWORD PTR [eax+1]
	cmp	esi, -2					; fffffffeH
	ja	$LN277@uflow@2
	mov	ecx, DWORD PTR __Str$25479[ebp+20]
	cmp	ecx, esi
	jae	SHORT $LN90@uflow@2
	push	eax
	push	esi
	lea	ecx, DWORD PTR __Str$25479[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Str$25479[ebp+20]
	mov	eax, DWORD PTR __Str$25479[ebp+16]
	test	esi, esi
	je	SHORT $LN155@uflow@2
$LN288@uflow@2:
	cmp	ecx, 16					; 00000010H
	mov	ecx, DWORD PTR __Str$25479[ebp]
	jae	SHORT $LN140@uflow@2
	lea	ecx, DWORD PTR __Str$25479[ebp]
$LN140@uflow@2:
	mov	BYTE PTR [ecx+eax], bl
	cmp	DWORD PTR __Str$25479[ebp+20], 16	; 00000010H
	mov	eax, DWORD PTR __Str$25479[ebp]
	mov	DWORD PTR __Str$25479[ebp+16], esi
	jae	SHORT $LN154@uflow@2
	lea	eax, DWORD PTR __Str$25479[ebp]
$LN154@uflow@2:
	mov	BYTE PTR [eax+esi], 0
$LN289@uflow@2:
	mov	eax, DWORD PTR __Str$25479[ebp+16]
	mov	ecx, DWORD PTR __Str$25479[ebp+20]
$LN155@uflow@2:

; 452  : 				switch (_Pcvt->in(_State,
; 453  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 454  : 					&_Ch, &_Ch + 1, _Dest))

	mov	edx, DWORD PTR __Str$25479[ebp]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN162@uflow@2
	mov	DWORD PTR $T33123[ebp], edx
	jmp	SHORT $LN163@uflow@2

; 450  : 
; 451  : 				_Str.append(1, (char)_Meta);	// append byte and convert

$LN90@uflow@2:
	test	esi, esi
	jne	SHORT $LN288@uflow@2
	mov	eax, DWORD PTR __Str$25479[ebp]
	mov	DWORD PTR __Str$25479[ebp+16], esi
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN130@uflow@2
	lea	eax, DWORD PTR __Str$25479[ebp]
$LN130@uflow@2:
	mov	BYTE PTR [eax], 0
	jmp	SHORT $LN289@uflow@2

; 452  : 				switch (_Pcvt->in(_State,
; 453  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 454  : 					&_Ch, &_Ch + 1, _Dest))

$LN162@uflow@2:
	lea	esi, DWORD PTR __Str$25479[ebp]
	mov	DWORD PTR $T33123[ebp], esi
$LN163@uflow@2:
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN181@uflow@2
	lea	edx, DWORD PTR __Str$25479[ebp]
$LN181@uflow@2:
	mov	ecx, DWORD PTR [edi+68]
	mov	esi, DWORD PTR [ecx]
	lea	ebx, DWORD PTR __Dest$25484[ebp]
	push	ebx
	lea	ebx, DWORD PTR __Ch$25483[ebp+1]
	push	ebx
	lea	ebx, DWORD PTR __Ch$25483[ebp]
	push	ebx
	lea	ebx, DWORD PTR __Src$25485[ebp]
	push	ebx
	mov	ebx, DWORD PTR $T33123[ebp]
	add	ebx, eax
	mov	eax, DWORD PTR [esi+16]
	push	ebx
	push	edx
	lea	edx, DWORD PTR [edi+76]
	push	edx
	call	eax
	test	eax, eax
	js	$LN1@uflow@2
	cmp	eax, 1
	jle	SHORT $LN8@uflow@2
	cmp	eax, 3
	jne	$LN1@uflow@2

; 468  : 					break;
; 469  : 
; 470  : 				case codecvt_base::noconv:
; 471  : 					if (_Str.size() < sizeof (_Elem))

	cmp	DWORD PTR __Str$25479[ebp+16], 1
	jb	SHORT $LN4@uflow@2

; 472  : 						break;	// no conversion, but need more chars
; 473  : 
; 474  : 					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),

	cmp	DWORD PTR __Str$25479[ebp+20], 16	; 00000010H
	mov	eax, DWORD PTR __Str$25479[ebp]
	jae	SHORT $LN237@uflow@2
	lea	eax, DWORD PTR __Str$25479[ebp]
$LN237@uflow@2:
	push	1
	push	eax
	lea	ecx, DWORD PTR __Ch$25483[ebp]
	push	1
	push	ecx
	call	_memcpy_s

; 475  : 						sizeof (_Elem));	// copy raw bytes to element
; 476  : 
; 477  : 					return (_Traits::to_int_type(_Ch));	// return result

	movzx	esi, BYTE PTR __Ch$25483[ebp]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR __Str$25479[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, esi
	jmp	$LN14@uflow@2
$LN8@uflow@2:

; 455  : 					{	// test result of converting one element
; 456  : 				case codecvt_base::partial:
; 457  : 				case codecvt_base::ok:
; 458  : 					if (_Dest != &_Ch)

	lea	ecx, DWORD PTR __Ch$25483[ebp]
	cmp	DWORD PTR __Dest$25484[ebp], ecx
	jne	SHORT $LN280@uflow@2

; 464  : 						}
; 465  : 					else
; 466  : 						_Str.erase((size_t)0,	// partial, discard used input
; 467  : 							(size_t)(_Src - &*_Str.begin()));

	cmp	DWORD PTR __Str$25479[ebp+20], 16	; 00000010H
	mov	eax, DWORD PTR __Str$25479[ebp]
	jae	SHORT $LN219@uflow@2
	lea	eax, DWORD PTR __Str$25479[ebp]
$LN219@uflow@2:
	mov	edx, DWORD PTR __Src$25485[ebp]
	sub	edx, eax
	push	edx
	push	0
	lea	ecx, DWORD PTR __Str$25479[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
$LN4@uflow@2:

; 440  : 
; 441  : 			for (; ; )
; 442  : 				{	// get using codecvt facet
; 443  : 				_Elem _Ch, *_Dest;
; 444  : 				const char *_Src;
; 445  : 				int _Nleft;
; 446  : 				int _Meta = fgetc(_Myfile);

	mov	eax, DWORD PTR [edi+84]
	push	eax
	call	_fgetc
	mov	ebx, eax
	add	esp, 4

; 447  : 
; 448  : 				if (_Meta == EOF)

	cmp	ebx, -1
	jne	$LL13@uflow@2
$LN276@uflow@2:

; 449  : 					return (_Traits::eof());	// partial char?

	lea	ecx, DWORD PTR __Str$25479[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN262@uflow@2
$LN277@uflow@2:

; 450  : 
; 451  : 				_Str.append(1, (char)_Meta);	// append byte and convert

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN290@uflow@2:
$LN280@uflow@2:

; 459  : 						{	// got an element, put back excess and deliver it
; 460  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

	cmp	DWORD PTR __Str$25479[ebp+20], 16	; 00000010H
	mov	esi, DWORD PTR __Str$25479[ebp]
	jae	SHORT $LN199@uflow@2
	lea	esi, DWORD PTR __Str$25479[ebp]
$LN199@uflow@2:
	sub	esi, DWORD PTR __Src$25485[ebp]
	add	esi, DWORD PTR __Str$25479[ebp+16]

; 461  : 						for (; 0 < _Nleft; )

	test	esi, esi
	jle	SHORT $LN5@uflow@2
$LN6@uflow@2:

; 462  : 							ungetc(_Src[--_Nleft], _Myfile);

	mov	eax, DWORD PTR __Src$25485[ebp]
	mov	edx, DWORD PTR [edi+84]
	movsx	ecx, BYTE PTR [esi+eax-1]
	dec	esi
	push	edx
	push	ecx
	call	_ungetc
	add	esp, 8
	test	esi, esi
	jg	SHORT $LN6@uflow@2
$LN5@uflow@2:

; 463  : 						return (_Traits::to_int_type(_Ch));

	movzx	esi, BYTE PTR __Ch$25483[ebp]
	lea	ecx, DWORD PTR __Str$25479[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, esi
	jmp	SHORT $LN14@uflow@2
$LN1@uflow@2:

; 478  : 
; 479  : 				default:
; 480  : 					return (_Traits::eof());	// conversion failed

	cmp	DWORD PTR __Str$25479[ebp+20], 16	; 00000010H
	jb	SHORT $LN262@uflow@2
	mov	edx, DWORD PTR __Str$25479[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN262@uflow@2:
	or	eax, -1
$LN14@uflow@2:

; 481  : 					}
; 482  : 				}
; 483  : 			}
; 484  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN286@uflow@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
	lea	ecx, DWORD PTR __Str$25479[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0
__ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -60					; size = 4
__Src$25335 = -56					; size = 4
__Dest$25336 = -52					; size = 4
__Ch$25334 = -45					; size = 1
__Str$25337 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 322  : 		{	// put an element to stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 323  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	mov	ebx, DWORD PTR __Meta$[ebp]
	mov	edi, ecx

; 345  : 			for (; ; )
; 346  : 				switch (_Pcvt->out(_State,
; 347  : 					&_Ch, &_Ch + 1, _Src,
; 348  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

	mov	DWORD PTR _this$GSCopy$[ebp], edi
	cmp	ebx, -1
	jne	SHORT $LN20@overflow

; 324  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	xor	eax, eax
	jmp	$LN14@overflow
$LN20@overflow:

; 325  : 		else if (_Mysb::pptr() != 0
; 326  : 			&& _Mysb::pptr() < _Mysb::epptr())

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN18@overflow
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax]
	add	edx, ecx
	cmp	ecx, edx
	jae	SHORT $LN18@overflow

; 327  : 			{	// room in buffer, store it
; 328  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR [ecx], bl

; 329  : 			return (_Meta);

	mov	eax, ebx
	jmp	$LN14@overflow
$LN18@overflow:

; 330  : 			}
; 331  : 		else if (_Myfile == 0)

	cmp	DWORD PTR [edi+84], 0

; 332  : 			return (_Traits::eof());	// no open C stream, fail

	je	$LN235@overflow

; 333  : 		_Reset_back();	// revert from _Mychar buffer

	mov	ecx, DWORD PTR [edi+16]
	lea	edx, DWORD PTR [edi+72]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN57@overflow
	mov	edx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [edi+48]
	sub	eax, eax
	mov	DWORD PTR [edx], eax
$LN57@overflow:

; 334  : 		if (_Pcvt == 0)

	cmp	DWORD PTR [edi+68], 0
	jne	SHORT $LN15@overflow

; 335  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
; 336  : 				? _Meta : _Traits::eof());	// no codecvt facet, put as is

	mov	edi, DWORD PTR [edi+84]
	movsx	eax, bl
	push	edi
	push	eax
	call	_fputc
	add	esp, 8
	cmp	eax, -1
	je	$LN235@overflow
	mov	eax, ebx
	jmp	$LN14@overflow
$LN15@overflow:

; 337  : 		else
; 338  : 			{	// put using codecvt facet
; 339  : 			const int _STRING_INC = 8;
; 340  : 			const _Elem _Ch = _Traits::to_char_type(_Meta);
; 341  : 			const _Elem *_Src;
; 342  : 			char *_Dest;
; 343  : 
; 344  : 			string _Str(_STRING_INC, '\0');

	lea	esi, DWORD PTR __Str$25337[ebp]
	mov	BYTE PTR __Ch$25334[ebp], bl
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN240@overflow:
	mov	ebx, DWORD PTR __Str$25337[ebp+20]
	mov	ecx, DWORD PTR __Str$25337[ebp]
	npad	2
$LL232@overflow:

; 377  : 				}

	mov	eax, DWORD PTR __Str$25337[ebp+16]
$LN13@overflow:

; 345  : 			for (; ; )
; 346  : 				switch (_Pcvt->out(_State,
; 347  : 					&_Ch, &_Ch + 1, _Src,
; 348  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

	mov	esi, ecx
	cmp	ebx, 16					; 00000010H
	jae	$LN237@overflow
	lea	esi, DWORD PTR __Str$25337[ebp]
	mov	edx, esi
$LN90@overflow:
	mov	ecx, DWORD PTR [edi+68]
	mov	ebx, DWORD PTR [ecx]
	add	esi, eax
	lea	edi, DWORD PTR __Dest$25336[ebp]
	push	edi
	mov	edi, DWORD PTR _this$GSCopy$[ebp]
	push	esi
	push	edx
	lea	edx, DWORD PTR __Src$25335[ebp]
	push	edx
	lea	eax, DWORD PTR __Ch$25334[ebp+1]
	push	eax
	lea	edx, DWORD PTR __Ch$25334[ebp]
	push	edx
	lea	eax, DWORD PTR [edi+76]
	push	eax
	mov	eax, DWORD PTR [ebx+20]
	call	eax
	test	eax, eax
	js	$LN1@overflow
	cmp	eax, 1
	jg	$LN227@overflow

; 349  : 				{	// test result of converting one element
; 350  : 				case codecvt_base::partial:
; 351  : 				case codecvt_base::ok:
; 352  : 					{	// converted something, try to put it out
; 353  : 					size_t _Count = _Dest - &*_Str.begin();

	mov	ebx, DWORD PTR __Str$25337[ebp+20]
	mov	ecx, DWORD PTR __Str$25337[ebp]
	mov	eax, ecx
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN108@overflow
	lea	eax, DWORD PTR __Str$25337[ebp]
$LN108@overflow:
	mov	esi, DWORD PTR __Dest$25336[ebp]
	sub	esi, eax

; 354  : 					if (0 < _Count && _Count !=
; 355  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

	je	SHORT $LN8@overflow
	mov	eax, ecx
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN124@overflow
	lea	eax, DWORD PTR __Str$25337[ebp]
$LN124@overflow:
	mov	ecx, DWORD PTR [edi+84]
	push	ecx
	push	esi
	push	1
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	cmp	esi, eax
	jne	$LN1@overflow
	mov	ebx, DWORD PTR __Str$25337[ebp+20]
	mov	ecx, DWORD PTR __Str$25337[ebp]
$LN8@overflow:

; 356  : 						return (_Traits::eof());	// write failed
; 357  : 
; 358  : 					_Wrotesome = true;	// write succeeded
; 359  : 					if (_Src != &_Ch)

	lea	edx, DWORD PTR __Ch$25334[ebp]
	mov	BYTE PTR [edi+73], 1
	cmp	DWORD PTR __Src$25335[ebp], edx
	jne	$LN229@overflow

; 361  : 
; 362  : 					if (0 < _Count)

	test	esi, esi
	jne	$LL232@overflow

; 363  : 						;
; 364  : 					else if (_Str.size() < 4 * _STRING_INC)

	mov	eax, DWORD PTR __Str$25337[ebp+16]
	cmp	eax, 32					; 00000020H
	jae	$LN1@overflow

; 365  : 						_Str.append(_STRING_INC, '\0');	// try with more space

	or	edx, -1
	sub	edx, eax
	cmp	edx, 8
	jbe	$LN230@overflow
	lea	esi, DWORD PTR [eax+8]
	cmp	esi, -2					; fffffffeH
	ja	$LN230@overflow
	cmp	ebx, esi
	jae	SHORT $LN150@overflow
	push	eax
	push	esi
	lea	ecx, DWORD PTR __Str$25337[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ebx, DWORD PTR __Str$25337[ebp+20]
	mov	eax, DWORD PTR __Str$25337[ebp+16]
	mov	ecx, DWORD PTR __Str$25337[ebp]
	test	esi, esi
	je	$LN13@overflow
$LN239@overflow:
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN206@overflow
	lea	ecx, DWORD PTR __Str$25337[ebp]
$LN206@overflow:
	pxor	xmm0, xmm0
	movq	QWORD PTR [ecx+eax], xmm0
	cmp	DWORD PTR __Str$25337[ebp+20], 16	; 00000010H
	mov	eax, DWORD PTR __Str$25337[ebp]
	mov	DWORD PTR __Str$25337[ebp+16], esi
	jae	SHORT $LN214@overflow
	lea	eax, DWORD PTR __Str$25337[ebp]
$LN214@overflow:
	mov	BYTE PTR [eax+esi], 0

; 377  : 				}

	jmp	$LN240@overflow
$LN237@overflow:

; 345  : 			for (; ; )
; 346  : 				switch (_Pcvt->out(_State,
; 347  : 					&_Ch, &_Ch + 1, _Src,
; 348  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

	mov	edx, ecx
	jmp	$LN90@overflow

; 365  : 						_Str.append(_STRING_INC, '\0');	// try with more space

$LN150@overflow:
	test	esi, esi
	jne	SHORT $LN239@overflow
	mov	DWORD PTR __Str$25337[ebp+16], esi
	mov	eax, ecx
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN190@overflow
	lea	eax, DWORD PTR __Str$25337[ebp]
$LN190@overflow:
	mov	BYTE PTR [eax], 0
	jmp	$LN240@overflow
$LN227@overflow:

; 345  : 			for (; ; )
; 346  : 				switch (_Pcvt->out(_State,
; 347  : 					&_Ch, &_Ch + 1, _Src,
; 348  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

	cmp	eax, 3
	jne	SHORT $LN1@overflow

; 366  : 					else
; 367  : 						return (_Traits::eof());	// conversion failed
; 368  : 					break;
; 369  : 					}
; 370  : 
; 371  : 				case codecvt_base::noconv:
; 372  : 					return (_Fputc(_Ch, _Myfile) ? _Meta
; 373  : 						: _Traits::eof());	// no conversion, put as is

	mov	edi, DWORD PTR [edi+84]
	movsx	eax, BYTE PTR __Ch$25334[ebp]
	push	edi
	push	eax
	call	_fputc
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN25@overflow
	mov	esi, DWORD PTR __Meta$[ebp]
	lea	ecx, DWORD PTR __Str$25337[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, esi
	jmp	SHORT $LN14@overflow
$LN25@overflow:
	lea	ecx, DWORD PTR __Str$25337[ebp]
	or	esi, -1
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, esi
	jmp	SHORT $LN14@overflow
$LN229@overflow:

; 360  : 						return (_Meta);	// converted whole element

	lea	ecx, DWORD PTR __Str$25337[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR __Meta$[ebp]
	jmp	SHORT $LN14@overflow
$LN230@overflow:

; 365  : 						_Str.append(_STRING_INC, '\0');	// try with more space

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN242@overflow:
$LN1@overflow:

; 374  : 
; 375  : 				default:
; 376  : 					return (_Traits::eof());	// conversion failed

	lea	ecx, DWORD PTR __Str$25337[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN235@overflow:
	or	eax, -1
$LN14@overflow:

; 378  : 			}
; 379  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN234@overflow:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0:
	lea	ecx, DWORD PTR __Str$25337[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = eax

; 163  : 		{	// point to next character and return it

	push	esi
	mov	esi, eax

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN17@snextc
	mov	ecx, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, 1
	jle	SHORT $LN5@snextc
	mov	eax, DWORD PTR [esi+48]
	dec	DWORD PTR [eax]
	mov	esi, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi]
	inc	eax
	mov	DWORD PTR [esi], eax
	movzx	eax, BYTE PTR [eax]
	pop	esi

; 168  : 		}

	ret	0
$LN5@snextc:

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

	test	eax, eax
	je	SHORT $LN17@snextc
	mov	edx, DWORD PTR [esi+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN17@snextc
	mov	eax, edx
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
	movzx	eax, BYTE PTR [ecx]
	jmp	SHORT $LN18@snextc
$LN17@snextc:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+28]
	mov	ecx, esi
	call	edx
$LN18@snextc:
	cmp	eax, -1
	jne	SHORT $LN3@snextc
	or	eax, eax
	pop	esi

; 168  : 		}

	ret	0
$LN3@snextc:

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN35@snextc
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN35@snextc
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	pop	esi

; 168  : 		}

	ret	0

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

$LN35@snextc:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+24]
	mov	ecx, esi
	pop	esi
	jmp	edx
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__Lock$34210 = -8					; size = 4
_this$ = -4						; size = 4
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 80   : 		_DELETE_CRT(_Plocale);

	mov	ebx, DWORD PTR [esi+56]
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	test	ebx, ebx
	je	SHORT $LN6@basic_stre@2
	push	edi
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN12@basic_stre@2
	push	0
	lea	ecx, DWORD PTR __Lock$34210[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN14@basic_stre@2
	cmp	eax, -1
	jae	SHORT $LN14@basic_stre@2
	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN14@basic_stre@2:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	lea	ecx, DWORD PTR __Lock$34210[ebp]
	not	esi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	and	esi, edi
	je	SHORT $LN18@basic_stre@2
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN18@basic_stre@2:
	mov	esi, DWORD PTR _this$[ebp]
$LN12@basic_stre@2:
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN6@basic_stre@2:

; 81   : 		}

	lea	ecx, DWORD PTR [esi+4]
	call	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ
_TEXT	SEGMENT
?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::tellg, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 850  : 		{	// return input stream position

	push	ecx

; 851  : 		if (!ios_base::fail())

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	test	BYTE PTR [eax+edx+12], 6
	jne	SHORT $LN2@tellg

; 852  : 			return (_Myios::rdbuf()->pubseekoff(0,
; 853  : 				ios_base::cur, ios_base::in));

	mov	ecx, DWORD PTR [eax+edx+56]
	mov	edx, DWORD PTR [ecx]
	push	1
	push	1
	xor	eax, eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edx+40]
	push	esi
	call	eax

; 854  : 		else
; 855  : 			return (pos_type(_BADOFF));

	mov	eax, esi
	pop	ecx

; 856  : 		}

	ret	0
$LN2@tellg:

; 854  : 		else
; 855  : 			return (pos_type(_BADOFF));

	mov	ecx, DWORD PTR ?_BADOFF@std@@3_JB
	mov	edx, DWORD PTR ?_BADOFF@std@@3_JB+4
	xor	eax, eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	mov	eax, esi
	pop	ecx

; 856  : 		}

	ret	0
?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::tellg
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[ebp]
	push	edi
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	pop	edi
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar@11
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@11:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
__Lock$34300 = -4					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 451  : 		{	// get locale

	push	ebp
	mov	ebp, esp
	push	ecx

; 452  : 		return (*_Ploc);

	mov	ecx, DWORD PTR [eax+48]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	0
	lea	ecx, DWORD PTR __Lock$34300[ebp]
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN5@getloc@2
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN5@getloc@2:
	lea	ecx, DWORD PTR __Lock$34300[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, edi
	pop	esi

; 453  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
$T34313 = 8						; size = 4
__Message$ = 8						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = esi
; __Errcode$ = eax

; 237  : 			{	// construct with message

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR __Message$[ebp]
	lea	ecx, DWORD PTR $T34313[ebp]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T34313[ebp], eax
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi+12], edi

; 238  : 			}

	pop	edi
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
	mov	eax, esi
	pop	ebx
	pop	ebp
	ret	4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2394 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 2395 : 		_Tidy();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	test	eax, eax
	jle	SHORT $LN13@ctype
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	_free
	add	esp, 4

; 2396 : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
$LN13@ctype:

; 2395 : 		_Tidy();

	jns	SHORT $LN12@ctype
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN12@ctype:

; 2396 : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T34370 = -16						; size = 16
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = esi

; 2365 : 		{	// construct from current locale

	push	ebp
	mov	ebp, esp

; 2366 : 		_Init(_Lobj);

	lea	eax, DWORD PTR $T34370[ebp]
	sub	esp, 16					; 00000010H
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	call	__Getctype
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [esi+8], xmm0
	movq	xmm0, QWORD PTR [eax+8]
	add	esp, 4
	movq	QWORD PTR [esi+16], xmm0

; 2367 : 		}

	mov	eax, esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN8@scalar@12
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@12:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gcodecvt_base@std@@UAEPAXI@Z PROC			; std::codecvt_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN8@scalar@13
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@13:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gcodecvt_base@std@@UAEPAXI@Z ENDP			; std::codecvt_base::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@DDH@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$codecvt@DDH@std@@MAEPAXI@Z PROC			; std::codecvt<char,char,int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN10@scalar@14
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@14:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$codecvt@DDH@std@@MAEPAXI@Z ENDP			; std::codecvt<char,char,int>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0
__ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Dest$26085 = -48					; size = 4
__Str$26089 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 587  : 		{	// put shift to initial conversion state, as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _this$[ebp]

; 588  : 		if (_Pcvt == 0 || !_Wrotesome)

	cmp	DWORD PTR [ebx+68], 0
	je	$LN14@Endwrite
	cmp	BYTE PTR [ebx+73], 0
	je	$LN14@Endwrite

; 590  : 		else
; 591  : 			{	// may have to put
; 592  : 			const int _STRING_INC = 8;
; 593  : 			char *_Dest;
; 594  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+12]
	push	-1
	mov	ecx, ebx
	call	edx
	cmp	eax, -1

; 595  : 				return (false);

	je	$LN186@Endwrite

; 596  : 
; 597  : 			string _Str(_STRING_INC, '\0');

	lea	esi, DWORD PTR __Str$26089[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN185@Endwrite:
	mov	edi, DWORD PTR __Str$26089[ebp+20]
	mov	eax, DWORD PTR __Str$26089[ebp]
$LN11@Endwrite:

; 598  : 			for (; ; )
; 599  : 				switch (_Pcvt->unshift(_State,
; 600  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

	mov	edx, eax
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN48@Endwrite
	lea	edx, DWORD PTR __Str$26089[ebp]
	mov	eax, edx
$LN48@Endwrite:
	mov	ecx, DWORD PTR [ebx+68]
	mov	esi, DWORD PTR [ecx]
	lea	edi, DWORD PTR __Dest$26085[ebp]
	push	edi
	mov	edi, DWORD PTR __Str$26089[ebp+16]
	add	edi, edx
	push	edi
	push	eax
	lea	eax, DWORD PTR [ebx+76]
	push	eax
	mov	eax, DWORD PTR [esi+24]
	call	eax
	sub	eax, 0
	je	SHORT $LN7@Endwrite
	dec	eax
	je	SHORT $LN6@Endwrite
	sub	eax, 2

; 615  : 					break;
; 616  : 					}
; 617  : 
; 618  : 				case codecvt_base::noconv:
; 619  : 					return (true);	// nothing to do
; 620  : 
; 621  : 				default:
; 622  : 					return (false);	// conversion failed

	lea	ecx, DWORD PTR __Str$26089[ebp]
	je	$LN2@Endwrite
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	xor	al, al
	jmp	$LN13@Endwrite
$LN7@Endwrite:

; 601  : 				{	// test result of homing conversion
; 602  : 				case codecvt_base::ok:
; 603  : 					_Wrotesome = false;	// homed successfully

	mov	BYTE PTR [ebx+73], 0
$LN6@Endwrite:

; 604  : 
; 605  : 				case codecvt_base::partial:	// fall through
; 606  : 					{	// put any generated bytes
; 607  : 					size_t _Count = _Dest - &*_Str.begin();

	mov	edi, DWORD PTR __Str$26089[ebp+20]
	mov	eax, DWORD PTR __Str$26089[ebp]
	mov	ecx, eax
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN66@Endwrite
	lea	ecx, DWORD PTR __Str$26089[ebp]
$LN66@Endwrite:
	mov	esi, DWORD PTR __Dest$26085[ebp]
	sub	esi, ecx

; 608  : 					if (0 < _Count && _Count !=
; 609  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

	je	SHORT $LN5@Endwrite
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN82@Endwrite
	lea	eax, DWORD PTR __Str$26089[ebp]
$LN82@Endwrite:
	mov	ecx, DWORD PTR [ebx+84]
	push	ecx
	push	esi
	push	1
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	cmp	esi, eax
	jne	$LN173@Endwrite
	mov	edi, DWORD PTR __Str$26089[ebp+20]
	mov	eax, DWORD PTR __Str$26089[ebp]
$LN5@Endwrite:

; 611  : 					if (!_Wrotesome)

	cmp	BYTE PTR [ebx+73], 0
	je	$LN174@Endwrite

; 613  : 					if (_Count == 0)

	test	esi, esi
	jne	$LN11@Endwrite

; 614  : 						_Str.append(_STRING_INC, '\0');	// try with more space

	mov	ecx, DWORD PTR __Str$26089[ebp+16]
	or	edx, -1
	sub	edx, ecx
	cmp	edx, 8
	jbe	$LN175@Endwrite
	lea	esi, DWORD PTR [ecx+8]
	cmp	esi, -2					; fffffffeH
	ja	$LN175@Endwrite
	cmp	edi, esi
	jae	SHORT $LN104@Endwrite
	push	ecx
	push	esi
	lea	ecx, DWORD PTR __Str$26089[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	edi, DWORD PTR __Str$26089[ebp+20]
	mov	eax, DWORD PTR __Str$26089[ebp]
	test	esi, esi
	je	$LN11@Endwrite
$LN184@Endwrite:
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN160@Endwrite
	lea	eax, DWORD PTR __Str$26089[ebp]
$LN160@Endwrite:
	mov	ecx, DWORD PTR __Str$26089[ebp+16]
	pxor	xmm0, xmm0
	movq	QWORD PTR [eax+ecx], xmm0
	cmp	DWORD PTR __Str$26089[ebp+20], 16	; 00000010H
	mov	eax, DWORD PTR __Str$26089[ebp]
	mov	DWORD PTR __Str$26089[ebp+16], esi
	jae	SHORT $LN168@Endwrite
	lea	eax, DWORD PTR __Str$26089[ebp]
$LN168@Endwrite:
	mov	BYTE PTR [eax+esi], 0

; 623  : 				}

	jmp	$LN185@Endwrite

; 614  : 						_Str.append(_STRING_INC, '\0');	// try with more space

$LN104@Endwrite:
	test	esi, esi
	jne	SHORT $LN184@Endwrite
	mov	DWORD PTR __Str$26089[ebp+16], esi
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN144@Endwrite
	lea	eax, DWORD PTR __Str$26089[ebp]
$LN144@Endwrite:
	mov	BYTE PTR [eax], 0
	jmp	$LN185@Endwrite
$LN173@Endwrite:

; 610  : 						return (false);	// write failed

	lea	ecx, DWORD PTR __Str$26089[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN186@Endwrite:
	xor	al, al
	jmp	SHORT $LN13@Endwrite
$LN174@Endwrite:

; 612  : 						return (true);

	lea	ecx, DWORD PTR __Str$26089[ebp]
$LN2@Endwrite:
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN14@Endwrite:

; 589  : 			return (true);

	mov	al, 1
$LN13@Endwrite:

; 624  : 			}
; 625  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN175@Endwrite:

; 614  : 						_Str.append(_STRING_INC, '\0');	// try with more space

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN187@Endwrite:
$LN180@Endwrite:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0:
	lea	ecx, DWORD PTR __Str$26089[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
; Function compile flags: /Ogtp
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = esi

; 292  : 		{	// close the C stream

	push	ebx

; 293  : 		_Myt *_Ans = this;
; 294  : 		if (_Myfile == 0)

	xor	ebx, ebx
	push	edi
	mov	edi, esi
	cmp	DWORD PTR [esi+84], ebx

; 295  : 			_Ans = 0;
; 296  : 		else

	je	SHORT $LN18@close

; 297  : 			{	// put any homing sequence and close file
; 298  : 			if (!_Endwrite())

	push	esi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al

; 299  : 				_Ans = 0;
; 300  : 			if (fclose(_Myfile) != 0)

	mov	eax, DWORD PTR [esi+84]
	push	eax
	cmove	edi, ebx
	call	_fclose
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@close
$LN18@close:

; 301  : 				_Ans = 0;

	xor	edi, edi
$LN1@close:

; 302  : 			}
; 303  : 		_Init(0, _Closefl);

	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], ecx
	mov	BYTE PTR [esi+80], bl
	mov	BYTE PTR [esi+73], bl
	lea	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+32], edx
	lea	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+36], ecx
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+20], eax
	lea	edx, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+48], edx
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [eax], ebx
	mov	edx, DWORD PTR [esi+36]
	mov	DWORD PTR [edx], ebx
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax], ebx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx], ebx
	mov	edx, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
	mov	DWORD PTR [edx], ebx
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], ebx

; 304  : 		return (_Ans);

	mov	eax, edi
	pop	edi
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+68], ebx
	mov	DWORD PTR [esi+76], ecx
	pop	ebx

; 305  : 		}

	ret	0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = esi

; 152  : 		{	// construct from pointer to C stream

	push	esi
	call	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >

; 153  : 		_Init(_File, _Newfl);

	lea	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+32], edx
	xor	ecx, ecx
	lea	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+36], edx
	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], eax
	lea	edx, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+48], edx
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	BYTE PTR [esi+80], cl
	mov	BYTE PTR [esi+73], cl
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+20], eax
	lea	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+52], edx
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [esi+84], ecx
	mov	DWORD PTR [esi+76], edx
	mov	DWORD PTR [esi+68], ecx

; 154  : 		}

	mov	eax, esi
	ret	0
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$0
__ehfuncinfo$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Lock$35085 = -20					; size = 4
$T35070 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR [ebx], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR $T35070[ebp], eax
	test	eax, eax
	je	SHORT $LN9@scalar@15
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN15@scalar@15
	push	0
	lea	ecx, DWORD PTR __Lock$35085[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN17@scalar@15
	cmp	eax, -1
	jae	SHORT $LN17@scalar@15
	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN17@scalar@15:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	lea	ecx, DWORD PTR __Lock$35085[ebp]
	not	esi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	and	esi, edi
	je	SHORT $LN22@scalar@15
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN22@scalar@15:
	mov	eax, DWORD PTR $T35070[ebp]
$LN15@scalar@15:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@15:
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN21@scalar@15
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@scalar@15:
	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
__ehhandler$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
__Fileposition$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 512  : 		{	// change position to _Pos

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 513  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);

	mov	eax, DWORD PTR __Pos$[ebp+8]
	push	ebx

; 514  : 		off_type _Off = (off_type)_Pos - (off_type)_FPOSOFF(_Fileposition);

	mov	ebx, DWORD PTR __Pos$[ebp+4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Pos$[ebp+12]
	mov	DWORD PTR __Fileposition$[esp+24], ecx

; 515  : 
; 516  : 		if (_Myfile == 0 || !_Endwrite()
; 517  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 518  : 			|| _Off != 0 && _FSEEK_OFF(_Myfile, _Off, SEEK_CUR) != 0
; 519  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

	xor	ecx, ecx
	push	edi
	mov	edi, DWORD PTR __Pos$[ebp]
	mov	DWORD PTR __Fileposition$[esp+24], eax
	cmp	DWORD PTR [esi+84], ecx
	je	$LN2@seekpos
	push	esi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	SHORT $LN16@seekpos
	mov	eax, DWORD PTR [esi+84]
	lea	edx, DWORD PTR __Fileposition$[esp+24]
	push	edx
	push	eax
	call	_fsetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@seekpos
	mov	ecx, edi
	or	ecx, ebx
	je	SHORT $LN1@seekpos
	mov	edx, DWORD PTR [esi+84]
	push	1
	push	ebx
	push	edi
	push	edx
	call	__fseeki64
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN16@seekpos
$LN1@seekpos:
	mov	ecx, DWORD PTR [esi+84]
	lea	eax, DWORD PTR __Fileposition$[esp+24]
	push	eax
	push	ecx
	call	_fgetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@seekpos

; 521  : 
; 522  : 		_State = _POS_TYPE_TO_STATE(_Pos);

	mov	edx, DWORD PTR __Pos$[ebp+16]

; 523  : 
; 524  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

	mov	eax, esi
	mov	DWORD PTR [esi+76], edx
	call	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 525  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Fileposition$[esp+24]
	mov	edx, DWORD PTR __Fileposition$[esp+28]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx

; 526  : 			_Fileposition));	// return new position
; 527  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN16@seekpos:

; 525  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

	xor	ecx, ecx
$LN2@seekpos:

; 520  : 			return (pos_type(_BADOFF));	// report failure

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR ?_BADOFF@std@@3_JB

; 526  : 			_Fileposition));	// return new position
; 527  : 		}

	pop	edi
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR ?_BADOFF@std@@3_JB+4
	pop	esi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z
_TEXT	SEGMENT
__Fileposition$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 490  : 		{	// change position by _Off

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 491  : 		fpos_t _Fileposition;
; 492  : 
; 493  : 		if (_Mysb::gptr() == &_Mychar	// something putback
; 494  : 			&& _Way == ios_base::cur	// a relative seek
; 495  : 			&& _Pcvt == 0)	// not converting

	mov	ecx, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [esi+72]
	push	edi
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN21@seekoff
	cmp	DWORD PTR __Way$[ebp], 1
	jne	SHORT $LN21@seekoff
	cmp	DWORD PTR [esi+68], 0
	jne	SHORT $LN21@seekoff

; 496  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

	mov	ebx, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	add	ebx, -1
	adc	edi, -1
	jmp	SHORT $LN5@seekoff
$LN21@seekoff:
	mov	edi, DWORD PTR __Off$[ebp+4]
	mov	ebx, DWORD PTR __Off$[ebp]
$LN5@seekoff:

; 497  : 
; 498  : 		if (_Myfile == 0 || !_Endwrite()
; 499  : 			|| (_Off != 0 || _Way != ios_base::cur)
; 500  : 				&& _FSEEK_OFF(_Myfile, _Off, _Way) != 0
; 501  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

	cmp	DWORD PTR [esi+84], 0
	je	$LN3@seekoff
	push	esi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	$LN3@seekoff
	mov	edx, ebx
	or	edx, edi
	jne	SHORT $LN1@seekoff
	cmp	DWORD PTR __Way$[ebp], 1
	je	SHORT $LN2@seekoff
$LN1@seekoff:
	mov	eax, DWORD PTR __Way$[ebp]
	mov	ecx, DWORD PTR [esi+84]
	push	eax
	push	edi
	push	ebx
	push	ecx
	call	__fseeki64
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN3@seekoff
$LN2@seekoff:
	mov	eax, DWORD PTR [esi+84]
	lea	edx, DWORD PTR __Fileposition$[esp+24]
	push	edx
	push	eax
	call	_fgetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@seekoff

; 503  : 
; 504  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

	mov	ecx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [esi+72]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN17@seekoff
	mov	edx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [esi+48]
	sub	eax, eax
	mov	DWORD PTR [edx], eax
$LN17@seekoff:

; 505  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Fileposition$[esp+24]
	mov	edx, DWORD PTR __Fileposition$[esp+28]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx

; 506  : 			_Fileposition));	// return new position
; 507  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN3@seekoff:

; 502  : 			return (pos_type(_BADOFF));	// report failure

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
	mov	edx, DWORD PTR ?_BADOFF@std@@3_JB

; 506  : 			_Fileposition));	// return new position
; 507  : 		}

	pop	edi
	mov	DWORD PTR [eax+4], ecx
	xor	ecx, ecx
	pop	esi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$1
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Lock$35245 = -20					; size = 4
$T35230 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 143  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 144  : 		if (_Myfile != 0)

	cmp	DWORD PTR [esi+84], 0
	je	SHORT $LN11@basic_file

; 145  : 			_Reset_back();	// revert from _Mychar buffer

	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [esi+72]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN11@basic_file
	mov	edx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [esi+48]
	sub	eax, eax
	mov	DWORD PTR [edx], eax
$LN11@basic_file:

; 146  : 		if (_Closef)

	cmp	BYTE PTR [esi+80], 0
	je	SHORT $LN1@basic_file

; 147  : 			close();

	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN1@basic_file:

; 148  : 		}

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR $T35230[ebp], eax
	test	eax, eax
	je	SHORT $LN18@basic_file
	mov	ebx, DWORD PTR [eax]
	test	ebx, ebx
	je	SHORT $LN24@basic_file
	push	0
	lea	ecx, DWORD PTR __Lock$35245[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN26@basic_file
	cmp	eax, -1
	jae	SHORT $LN26@basic_file
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN26@basic_file:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	lea	ecx, DWORD PTR __Lock$35245[ebp]
	not	edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	and	edi, ebx
	je	SHORT $LN30@basic_file
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, edi
	call	edx
$LN30@basic_file:
	mov	eax, DWORD PTR $T35230[ebp]
$LN24@basic_file:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@basic_file:
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	SEGMENT
__unwindtable$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1302 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR [ecx-112]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-112], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@

; 1303 : 		}

	lea	esi, DWORD PTR [ecx-88]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	mov	eax, DWORD PTR [esi-24]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+esi-24], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
	mov	edx, DWORD PTR [esi-8]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+esi-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR [esi-24]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+esi-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 88					; 00000058H
	jmp	??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__ehhandler$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__ehfuncinfo$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T35312 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR [ecx]
	lea	edi, DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T35312[ebp], edi
	mov	DWORD PTR [ecx+edi-112], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
	lea	ecx, DWORD PTR [edi-88]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR [edi-112]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+edi-112], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR [edi-96]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+edi-96], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi-112]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+edi-112], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	push	edi
	mov	DWORD PTR [edi], OFFSET ??_7ios_base@std@@6B@
	call	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:
	mov	ecx, DWORD PTR $T35312[ebp]
	sub	ecx, 88					; 00000058H
	jmp	??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__ehhandler$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T35335 = -20						; size = 20
$T35333 = -20						; size = 20
$T35331 = -20						; size = 20
$T35429 = 8						; size = 4
$T35393 = 8						; size = 4
$T35357 = 8						; size = 4
__Reraise$ = 8						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 310  : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 311  : 		_Mystate = (iostate)(_State & _Statmask);
; 312  : 		if ((_Mystate & _Except) == 0)
; 313  : 			;
; 314  : 		else if (_Reraise)

	cmp	BYTE PTR __Reraise$[ebp], 0
	push	esi
	push	edi
	je	SHORT $LN6@clear

; 315  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN60@clear:
$LN6@clear:

; 316  : 		else if (_Mystate & _Except & badbit)

	mov	eax, DWORD PTR [ecx+16]
	and	eax, DWORD PTR [ecx+12]

; 317  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	mov	esi, 1
	test	al, 4
	je	SHORT $LN4@clear
	call	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
	mov	edi, eax
	lea	eax, DWORD PTR $T35357[ebp]
	push	eax
	lea	ecx, DWORD PTR $T35331[ebp]
	mov	DWORD PTR $T35357[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI4?AVfailure@ios_base@std@@
	lea	ecx, DWORD PTR $T35331[ebp]
	push	ecx
	mov	DWORD PTR $T35331[ebp+12], esi
	mov	DWORD PTR $T35331[ebp+16], edi
	mov	DWORD PTR $T35331[ebp], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN61@clear:
$LN4@clear:

; 318  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN2@clear

; 319  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	call	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
	lea	edx, DWORD PTR $T35393[ebp]
	push	edx
	lea	ecx, DWORD PTR $T35333[ebp]
	mov	edi, eax
	mov	DWORD PTR $T35393[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI4?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T35333[ebp]
	push	eax
	mov	DWORD PTR $T35333[ebp+12], esi
	mov	DWORD PTR $T35333[ebp+16], edi
	mov	DWORD PTR $T35333[ebp], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN62@clear:
$LN2@clear:

; 320  : 		else
; 321  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	call	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
	lea	ecx, DWORD PTR $T35429[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T35335[ebp]
	mov	edi, eax
	mov	DWORD PTR $T35429[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI4?AVfailure@ios_base@std@@
	lea	edx, DWORD PTR $T35335[ebp]
	push	edx
	mov	DWORD PTR $T35335[ebp+12], esi
	mov	DWORD PTR $T35335[ebp+16], edi
	mov	DWORD PTR $T35335[ebp], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN63@clear:
$LN59@clear:
	int	3
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	test	eax, eax
	jle	SHORT $LN16@scalar@16
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	_free
	jmp	SHORT $LN17@scalar@16
$LN16@scalar@16:
	jns	SHORT $LN6@scalar@16
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
$LN17@scalar@16:
	add	esp, 4
$LN6@scalar@16:
	test	BYTE PTR ___flags$[ebp], 1
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN15@scalar@16
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@scalar@16:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T35491 = -68						; size = 36
$T35549 = -32						; size = 16
$T35495 = -16						; size = 4
$T35490 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2371 : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2372 : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	edi, DWORD PTR __Ppf$[ebp]

; 2373 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 2374 : 				_Locinfo(_Ploc->c_str()));

	xor	ebx, ebx
	mov	DWORD PTR $T35495[ebp], ebx
	cmp	edi, ebx
	je	$LN28@Getcat@2

; 2372 : 		if (_Ppf != 0 && *_Ppf == 0)

	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN28@Getcat@2

; 2373 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 2374 : 				_Locinfo(_Ploc->c_str()));

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T35490[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	cmp	esi, ebx
	je	SHORT $LN4@Getcat@2
	mov	eax, DWORD PTR __Ploc$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, ebx
	jne	SHORT $LN15@Getcat@2
	lea	ecx, DWORD PTR [eax+28]
$LN15@Getcat@2:
	lea	edx, DWORD PTR $T35491[ebp]
	push	edx
	mov	edi, ecx
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	lea	eax, DWORD PTR $T35549[ebp]
	push	eax
	mov	ebx, 1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	call	__Getctype
	movq	xmm0, QWORD PTR [eax]
	mov	edi, DWORD PTR __Ppf$[ebp]
	movq	QWORD PTR [esi+8], xmm0
	movq	xmm0, QWORD PTR [eax+8]
	add	esp, 4
	movq	QWORD PTR [esi+16], xmm0
	jmp	SHORT $LN5@Getcat@2
$LN4@Getcat@2:
	xor	esi, esi
$LN5@Getcat@2:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi], esi
	test	bl, 1
	je	SHORT $LN28@Getcat@2
	lea	ecx, DWORD PTR $T35491[ebp]
	push	ecx
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN28@Getcat@2:

; 2375 : 		return (_X_CTYPE);

	mov	eax, 2

; 2376 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T35490[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T35563 = -36						; size = 12
__Lock$26480 = -24					; size = 4
__Lock$35571 = -20					; size = 4
__Lock$35593 = -20					; size = 4
__Psave$26481 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT
; __Loc$ = edi

; 504  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$26480[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 508  : 
; 509  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	DWORD PTR __Psave$26481[ebp], ebx
	jne	SHORT $LN11@use_facet@2
	push	0
	lea	ecx, DWORD PTR __Lock$35571[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
	jne	SHORT $LN10@use_facet@2
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet@2:
	lea	ecx, DWORD PTR __Lock$35571[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet@2:
	mov	esi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR [edi]
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet@2
	mov	ecx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	jne	SHORT $LN16@use_facet@2
$LN30@use_facet@2:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet@2
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN31@use_facet@2
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN15@use_facet@2
$LN20@use_facet@2:
	xor	ecx, ecx
	jmp	SHORT $LN30@use_facet@2
$LN16@use_facet@2:
	mov	esi, ecx
$LN15@use_facet@2:

; 511  : 
; 512  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN28@use_facet@2
$LN31@use_facet@2:

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet@2

; 515  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN28@use_facet@2
$LN4@use_facet@2:

; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$26481[ebp]
	push	edi
	push	eax
	call	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet@2

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T35563[ebp]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	ecx, DWORD PTR $T35563[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN37@use_facet@2:
$LN2@use_facet@2:

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$26481[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$35593[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN24@use_facet@2
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN24@use_facet@2:
	lea	ecx, DWORD PTR __Lock$35593[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 533  : 			_Pfmod->_Register();

	push	esi
	call	?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
	add	esp, 4
$LN28@use_facet@2:

; 534  : 			}
; 535  : 
; 536  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$26480[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 537  : 	_END_LOCK()
; 538  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@use_facet@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$26480[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	ENDS
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
__Lock$35637 = -16					; size = 4
__$EHRec$ = -12						; size = 12
$T35613 = 8						; size = 4
_this$ = 8						; size = 4
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT

; 124  : 		{	// convert _Byte to character using imbued locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 125  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

	mov	eax, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR $T35613[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edi, DWORD PTR $T35613[ebp]
	mov	ebx, eax
	test	edi, edi
	je	SHORT $LN7@widen
	push	0
	lea	ecx, DWORD PTR __Lock$35637[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN9@widen
	cmp	eax, -1
	jae	SHORT $LN9@widen
	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN9@widen:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	lea	ecx, DWORD PTR __Lock$35637[ebp]
	not	esi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	and	esi, edi
	je	SHORT $LN7@widen
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN7@widen:

; 126  : 		return (_Ctype_fac.widen(_Byte));

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+24]
	push	32					; 00000020H
	mov	ecx, ebx
	call	edx

; 127  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
	lea	ecx, DWORD PTR $T35613[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__Reraise$ = 8						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx
; __State$ = eax

; 42   : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	push	ecx

; 43   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 44   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN3@clear@2
	or	eax, 4
$LN3@clear@2:
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax
	test	DWORD PTR [ecx+16], eax
	je	SHORT $LN11@clear@2
	mov	eax, DWORD PTR __Reraise$[ebp]
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN11@clear@2:
	pop	ecx

; 45   : 		}

	pop	ebp
	ret	4
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar@17
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@17:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	lea	esi, DWORD PTR [ecx-112]
	mov	ecx, esi
	call	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar@18
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@18:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 54   : 		{	// merge _State into state, possible reraise exception

	push	ebp
	mov	ebp, esp

; 55   : 		if (_State != goodbit)
; 56   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	mov	eax, DWORD PTR [ecx+12]
	or	eax, DWORD PTR __State$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN11@setstate
	or	eax, 4
$LN11@setstate:
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax
	test	DWORD PTR [ecx+16], eax
	je	SHORT $LN19@setstate
	mov	eax, DWORD PTR __Reraise$[ebp]
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN19@setstate:

; 57   : 		}

	pop	ebp
	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = esi

; 571  : 		ios_base::iostate _State = ios_base::goodbit;
; 572  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	push	edi
	xor	edi, edi
	test	BYTE PTR [eax+esi+12], 6
	jne	SHORT $LN1@flush
	mov	eax, DWORD PTR [eax+esi+56]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+52]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1@flush

; 573  : 			_State |= ios_base::badbit;	// sync failed

	mov	edi, 4
$LN1@flush:

; 574  : 		_Myios::setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN35@flush
	mov	eax, DWORD PTR [ecx+12]
	or	eax, edi
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN19@flush
	or	eax, 4
$LN19@flush:
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax
	test	DWORD PTR [ecx+16], eax
	je	SHORT $LN35@flush
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN35@flush:

; 575  : 		return (*this);

	mov	eax, esi

; 576  : 		}

	pop	edi
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT
?clear@ios_base@std@@QAEXH@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 325  : 		{	// set state to argument

	push	ecx

; 326  : 		clear(_State, false);

	xor	al, al
	mov	DWORD PTR [ecx+12], 0
	je	SHORT $LN9@clear@3
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN9@clear@3:
	pop	ecx

; 327  : 		}

	ret	0
?clear@ios_base@std@@QAEXH@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = edi

; 116  : 		{	// test stream state and skip whitespace as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 117  : 		if (ios_base::good())

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+edi+12]
	add	ecx, edi
	test	eax, eax
	jne	SHORT $LN1@Ipfx

; 118  : 			{	// state okay, flush tied stream and skip whitespace
; 119  : 			if (_Myios::tie() != 0)

	mov	ecx, DWORD PTR [ecx+60]
	test	ecx, ecx
	je	SHORT $LL7@Ipfx

; 120  : 				_Myios::tie()->flush();

	mov	esi, ecx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LL7@Ipfx:

; 121  : 
; 122  : 			if (!_Noskip && ios_base::flags() & ios_base::skipws)
; 123  : 				{	// skip whitespace
; 124  : 				const _Ctype& _Ctype_fac = _USE(ios_base::getloc(), _Ctype);
; 125  : 
; 126  : 				_TRY_IO_BEGIN
; 127  : 				int_type _Meta = _Myios::rdbuf()->sgetc();
; 128  : 
; 129  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())
; 130  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 131  : 						{	// end of file, quit
; 132  : 						_Myios::setstate(ios_base::eofbit);
; 133  : 						break;
; 134  : 						}
; 135  : 					else if (!_Ctype_fac.is(_Ctype::space,
; 136  : 						_Traits::to_char_type(_Meta)))
; 137  : 						break;	// not whitespace, quit
; 138  : 				_CATCH_IO_END
; 139  : 				}
; 140  : 
; 141  : 			if (ios_base::good())

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, edi
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN1@Ipfx

; 142  : 				return (true);

	mov	al, 1

; 146  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@Ipfx:

; 143  : 			}
; 144  : 		_Myios::setstate(ios_base::failbit);

	mov	eax, DWORD PTR [ecx+12]
	or	eax, 2
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN108@Ipfx
	or	eax, 4
$LN108@Ipfx:
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax
	test	DWORD PTR [ecx+16], eax
	je	SHORT $LN116@Ipfx
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN116@Ipfx:

; 145  : 		return (false);

	xor	al, al

; 146  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Istr$ = 12						; size = 4
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 99   : 			{	// construct locking and calling _Ipfx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Istr$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+56]
	test	eax, eax
	je	SHORT $LN4@sentry@2
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN4@sentry@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 100  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	mov	edi, DWORD PTR [esi]
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	BYTE PTR [esi+4], al

; 101  : 			}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
;	COMDAT ?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z
_TEXT	SEGMENT
$T36248 = -28						; size = 24
__Way$ = 8						; size = 4
?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::seekg, COMDAT
; _this$ = esi

; 841  : 		{	// change input stream position by _Off, according to _Way

	push	ebp
	mov	ebp, esp

; 842  : 		if (!ios_base::fail()
; 843  : 			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
; 844  : 				ios_base::in) == _BADOFF)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	sub	esp, 28					; 0000001cH
	test	BYTE PTR [ecx+esi+12], 6
	jne	SHORT $LN39@seekg
	mov	edx, DWORD PTR __Way$[ebp]
	mov	ecx, DWORD PTR [ecx+esi+56]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+40]
	push	1
	push	edx
	push	0
	push	0
	lea	edx, DWORD PTR $T36248[ebp]
	push	edx
	call	eax
	mov	eax, DWORD PTR $T36248[ebp+8]
	cdq
	add	eax, DWORD PTR $T36248[ebp]
	adc	edx, DWORD PTR $T36248[ebp+4]
	cmp	eax, DWORD PTR ?_BADOFF@std@@3_JB
	jne	SHORT $LN39@seekg
	cmp	edx, DWORD PTR ?_BADOFF@std@@3_JB+4
	jne	SHORT $LN39@seekg

; 845  : 			_Myios::setstate(ios_base::failbit);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+esi+12]
	add	ecx, esi
	or	eax, 2
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN21@seekg
	or	eax, 4
$LN21@seekg:
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax
	test	DWORD PTR [ecx+16], eax
	je	SHORT $LN39@seekg
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN39@seekg:

; 846  : 		return (*this);

	mov	eax, esi

; 847  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::seekg
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z$0
__tryblocktable$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z$5
__ehfuncinfo$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Str$ = 12						; size = 4
__Count$ = 16						; size = 8
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z PROC ; std::basic_istream<char,std::char_traits<char> >::read, COMDAT

; 707  : 		{	// read up to _Count characters into buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, DWORD PTR _this$[ebp]

; 708  : 		_DEBUG_POINTER(_Str);
; 709  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi

; 710  : 		_Chcount = 0;

	mov	DWORD PTR [edi+8], esi
	mov	DWORD PTR [edi+12], esi

; 711  : 		const sentry _Ok(*this, true);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+edi+56]
	mov	DWORD PTR __State$[ebp], esi
	mov	DWORD PTR __Ok$[ebp], edi
	cmp	ecx, esi
	je	SHORT $LN14@read
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN14@read:
	mov	DWORD PTR __$EHRec$[ebp+12], esi
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	BYTE PTR __Ok$[ebp+4], al
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 712  : 
; 713  : 		if (_Ok)

	test	al, al
	je	SHORT $LN10@read

; 714  : 			{	// state okay, use facet to extract
; 715  : 			_TRY_IO_BEGIN
; 716  : 			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);

	mov	ebx, DWORD PTR __Count$[ebp+4]
	mov	esi, DWORD PTR __Count$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+edi+56]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Str$[ebp]
	mov	eax, DWORD PTR [eax+32]
	push	ebx
	push	esi
	push	edx
	call	eax

; 717  : 			_Chcount += _Num;

	add	DWORD PTR [edi+8], eax
	mov	ecx, edx
	adc	DWORD PTR [edi+12], ecx

; 718  : 			if (_Num != _Count)

	cmp	eax, esi
	jne	SHORT $LN82@read
	cmp	ecx, ebx
	je	SHORT $LN1@read
$LN82@read:

; 719  : 				_State |= ios_base::eofbit | ios_base::failbit;	// short read

	mov	DWORD PTR __State$[ebp], 3
$LN1@read:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT $LN87@read
__catch$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z$0:

; 720  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+12]
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN34@read
	or	eax, 4
$LN34@read:
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax
	test	DWORD PTR [ecx+16], eax
	je	SHORT $LN42@read
	push	1
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN42@read:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	eax, $LN85@read
	ret	0
$LN85@read:
	mov	edi, DWORD PTR _this$[ebp]
$LN87@read:
	xor	esi, esi
$LN10@read:

; 721  : 			}
; 722  : 
; 723  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, edi
	cmp	edx, esi
	je	SHORT $LN64@read
	mov	eax, DWORD PTR [ecx+12]
	or	eax, edx
	cmp	DWORD PTR [ecx+56], esi
	jne	SHORT $LN56@read
	or	eax, 4
$LN56@read:
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax
	test	DWORD PTR [ecx+16], eax
	je	SHORT $LN64@read
	push	esi
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN64@read:

; 724  : 		return (*this);

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+edi+56]
	cmp	ecx, esi
	je	SHORT $LN83@read
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN83@read:
	mov	eax, edi

; 725  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z$3:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::read
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
__Lock$36665 = -8					; size = 4
$T36661 = -4						; size = 4
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = esi

; 554  : 		{	// initialize a new ios_base

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	edi

; 555  : 		_Ploc = 0;

	xor	edi, edi

; 556  : 		_Stdstr = 0;
; 557  : 		_Except = goodbit;
; 558  : 		_Fmtfl = (fmtflags)(skipws | dec);
; 559  : 		_Prec = 6;
; 560  : 		_Wide = 0;
; 561  : 		_Arr = 0;
; 562  : 		_Calls = 0;
; 563  : 		clear(goodbit);
; 564  : 		_Ploc = _NEW_CRT locale;

	push	4
	mov	DWORD PTR [esi+48], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], 513			; 00000201H
	mov	DWORD PTR [esi+24], 6
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+12], edi
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	cmp	ebx, edi
	je	SHORT $LN3@Init@2
	call	?_Init@locale@std@@CAPAV_Locimp@12@XZ	; std::locale::_Init
	mov	DWORD PTR [ebx], eax
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	push	edi
	lea	ecx, DWORD PTR __Lock$36665[ebp]
	mov	DWORD PTR $T36661[ebp], eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	ecx, DWORD PTR $T36661[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, -1
	jae	SHORT $LN22@Init@2
	inc	eax
	mov	DWORD PTR [ecx+4], eax
$LN22@Init@2:
	lea	ecx, DWORD PTR __Lock$36665[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	DWORD PTR [esi+48], ebx

; 565  : 		}

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@Init@2:

; 556  : 		_Stdstr = 0;
; 557  : 		_Except = goodbit;
; 558  : 		_Fmtfl = (fmtflags)(skipws | dec);
; 559  : 		_Prec = 6;
; 560  : 		_Wide = 0;
; 561  : 		_Arr = 0;
; 562  : 		_Calls = 0;
; 563  : 		clear(goodbit);
; 564  : 		_Ploc = _NEW_CRT locale;

	mov	DWORD PTR [esi+48], edi

; 565  : 		}

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
__Strbuf$ = 8						; size = 4
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = eax

; 154  : 		{	// initialize with stream buffer pointer

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, eax

; 155  : 		_Init();	// initialize ios_base

	call	?_Init@ios_base@std@@IAEXXZ		; std::ios_base::_Init

; 156  : 		_Mystrbuf = _Strbuf;

	mov	eax, DWORD PTR __Strbuf$[ebp]

; 157  : 		_Tiestr = 0;
; 158  : 		_Fillch = widen(' ');

	push	esi
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], 0
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen

; 159  : 
; 160  : 		if (_Mystrbuf == 0)

	cmp	DWORD PTR [esi+56], 0
	mov	BYTE PTR [esi+64], al
	jne	SHORT $LN1@init

; 161  : 			setstate(badbit);

	mov	eax, DWORD PTR [esi+12]
	or	eax, 4
	and	eax, 23					; 00000017H
	mov	DWORD PTR [esi+12], eax
	test	DWORD PTR [esi+16], eax
	je	SHORT $LN1@init
	push	0
	mov	ecx, esi
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1@init:

; 162  : 
; 163  : 		if (_Isstd)
; 164  : 			_Addstd(this);	// special handling for standard streams
; 165  : 		}

	pop	esi
	pop	ebp
	ret	4
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
$T36753 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Strbuf$ = 12						; size = 4
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >, COMDAT

; 33   : 		{	// construct from stream buffer pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR _this$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR $T36753[ebp], ebx
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+ecx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@

; 34   : 		_Myios::init(_Strbuf, _Isstd);

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [edi+12], ebx
	mov	esi, DWORD PTR [edx+4]
	add	esi, edi
	call	?_Init@ios_base@std@@IAEXXZ		; std::ios_base::_Init
	mov	eax, DWORD PTR __Strbuf$[ebp]
	push	esi
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], ebx
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
	mov	BYTE PTR [esi+64], al
	cmp	DWORD PTR [esi+56], ebx
	jne	SHORT $LN37@basic_istr
	mov	eax, DWORD PTR [esi+12]
	or	eax, 4
	and	eax, 23					; 00000017H
	mov	DWORD PTR [esi+12], eax
	test	DWORD PTR [esi+16], eax
	je	SHORT $LN37@basic_istr
	push	ebx
	mov	ecx, esi
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN37@basic_istr:

; 35   : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1
	DD	02H
	DD	00H
__ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
$T36887 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Strbuf$ = 12						; size = 4
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >, COMDAT

; 939  : 		{	// construct from stream buffer pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR _this$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR $T36887[ebp], ebx
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+ecx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [edi+12], ebx
	mov	esi, DWORD PTR [edx+4]
	add	esi, edi
	call	?_Init@ios_base@std@@IAEXXZ		; std::ios_base::_Init
	mov	eax, DWORD PTR __Strbuf$[ebp]
	push	esi
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], ebx
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
	mov	BYTE PTR [esi+64], al
	cmp	DWORD PTR [esi+56], ebx
	jne	SHORT $LN40@basic_iost
	mov	eax, DWORD PTR [esi+12]
	or	eax, 4
	or	eax, 4
	and	eax, 23					; 00000017H
	mov	DWORD PTR [esi+12], eax
	test	DWORD PTR [esi+16], eax
	je	SHORT $LN40@basic_iost
	push	ebx
	mov	ecx, esi
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN40@basic_iost:
	mov	ecx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+edx+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+ecx], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@

; 940  : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2
__ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT
$T37094 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >, COMDAT

; 1171 : 		{	// construct with named file and specified mode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR $T37094[ebp], eax
	mov	DWORD PTR [edi], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
	mov	DWORD PTR [edi+16], OFFSET ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
	mov	DWORD PTR [edi+112], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
	lea	esi, DWORD PTR [edi+24]
	push	esi
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	push	edi
	mov	DWORD PTR $T37094[ebp], 1
	call	??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+ecx], OFFSET ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
	call	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >

; 1172 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
	test	eax, eax
	jne	SHORT $LN36@basic_fstr

; 1173 : 			_Myios::setstate(ios_base::failbit);

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+edi+12]
	add	ecx, edi
	or	eax, 2
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN20@basic_fstr
	or	eax, 4
$LN20@basic_fstr:
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax
	test	DWORD PTR [ecx+16], eax
	je	SHORT $LN36@basic_fstr
	push	0
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN36@basic_fstr:

; 1174 : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0:
	mov	eax, DWORD PTR $T37094[ebp]
	and	eax, 1
	je	$LN6@basic_fstr
	and	DWORD PTR $T37094[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN6@basic_fstr:
	ret	0
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	__$ArrayPad$
PUBLIC	?cl_build_program@@YAXXZ			; cl_build_program
EXTRN	__chkstk:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?cl_build_program@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?cl_build_program@@YAXXZ$0
__ehfuncinfo$?cl_build_program@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?cl_build_program@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\tdrol\documents\visual studio 2010\projects\analizator\analizator-bd-opencl\cl_encrypt.cpp
xdata$x	ENDS
;	COMDAT ?cl_build_program@@YAXXZ
_TEXT	SEGMENT
_f$ = -10472						; size = 184
$T37201 = -10288					; size = 24
_len$24589 = -10264					; size = 4
_source_str$ = -10260					; size = 4
_buffer$24590 = -10256					; size = 10240
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?cl_build_program@@YAXXZ PROC				; cl_build_program, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?cl_build_program@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, 10464				; 000028e0H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 47   : 	err = clGetPlatformIDs(1, &platform_id, NULL);

	push	0
	push	OFFSET _platform_id
	push	1
	call	DWORD PTR __imp__clGetPlatformIDs@12
	mov	DWORD PTR _err, eax

; 48   : 	if (err != CL_SUCCESS) {

	test	eax, eax
	je	SHORT $LN9@cl_build_p

; 49   : 		printf("Error: could not connect to compute device\n");

	push	OFFSET ??_C@_0CM@DGFADCLC@Error?3?5could?5not?5connect?5to?5comp@
	call	_printf
	add	esp, 4

; 50   : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 51   : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN21@cl_build_p:
$LN9@cl_build_p:

; 52   : 	}
; 53   : 
; 54   : 	device_id = NULL;
; 55   : 	// Get a device of the appropriate type
; 56   : 	err = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_GPU, 1, &device_id, NULL);

	mov	eax, DWORD PTR _platform_id
	mov	esi, DWORD PTR __imp__clGetDeviceIDs@24
	push	0
	push	OFFSET _device_id
	push	1
	push	0
	push	4
	push	eax
	mov	DWORD PTR _device_id, 0
	call	esi
	mov	DWORD PTR _err, eax

; 57   : 
; 58   : 	if (err != CL_SUCCESS) {

	test	eax, eax
	je	SHORT $LN8@cl_build_p

; 59   : 		printf("Warning: no GPU support, falling back to CPU\n");

	push	OFFSET ??_C@_0CO@IBFBJMIF@Warning?3?5no?5GPU?5support?0?5falling@
	call	_printf

; 60   : 
; 61   : 		err = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_CPU, 1, &device_id,
; 62   : 		                     NULL);

	mov	ecx, DWORD PTR _platform_id
	add	esp, 4
	push	0
	push	OFFSET _device_id
	push	1
	push	0
	push	2
	push	ecx
	call	esi
	mov	DWORD PTR _err, eax
$LN8@cl_build_p:

; 63   : 	}
; 64   : 
; 65   : 	if ( ! device_id) {

	cmp	DWORD PTR _device_id, 0
	jne	SHORT $LN7@cl_build_p

; 66   : 		printf("Error: could not get device id\n");

	push	OFFSET ??_C@_0CA@JGBMOJJG@Error?3?5could?5not?5get?5device?5id?6?$AA@
	call	_printf
	add	esp, 4

; 67   : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 68   : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN22@cl_build_p:
$LN7@cl_build_p:

; 69   : 	}
; 70   : 
; 71   : 	// Create a compute context
; 72   : 	context = clCreateContext(0, 1, &device_id, NULL, NULL, &err);

	push	OFFSET _err
	push	0
	push	0
	push	OFFSET _device_id
	push	1
	push	0
	call	DWORD PTR __imp__clCreateContext@24
	mov	DWORD PTR _context, eax

; 73   : 	if ( ! context) {

	test	eax, eax
	jne	SHORT $LN6@cl_build_p

; 74   : 		printf("Error: failed to create a compute context\n");

	push	OFFSET ??_C@_0CL@GFFLIIBK@Error?3?5failed?5to?5create?5a?5comput@
	call	_printf
	add	esp, 4

; 75   : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 76   : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN23@cl_build_p:
$LN6@cl_build_p:

; 77   : 	}
; 78   : 
; 79   : 	// Create a command queue
; 80   : 	queue = clCreateCommandQueue(context, device_id, 0, &err);

	mov	edx, DWORD PTR _device_id
	push	OFFSET _err
	push	0
	push	0
	push	edx
	push	eax
	call	DWORD PTR __imp__clCreateCommandQueue@20
	mov	DWORD PTR _queue, eax

; 81   : 	if ( ! queue) {

	test	eax, eax
	jne	SHORT $LN5@cl_build_p

; 82   : 		printf("Error: failed to create a command queue\n");

	push	OFFSET ??_C@_0CJ@CDIEGNMJ@Error?3?5failed?5to?5create?5a?5comman@
	call	_printf
	add	esp, 4

; 83   : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 84   : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN24@cl_build_p:
$LN5@cl_build_p:

; 85   : 	}
; 86   : 
; 87   : 	std::fstream f(source, std::ios::in);

	lea	eax, DWORD PTR _f$[ebp]
	push	eax
	call	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 88   : 
; 89   : 	if ( ! f.is_open())

	cmp	DWORD PTR _f$[ebp+108], 0
	jne	SHORT $LN4@cl_build_p

; 90   : 	{
; 91   : 		printf("Error: failed to open %s\n", source);

	push	OFFSET ??_C@_0BB@GKNLBPKG@?4?1aes?9encrypt?4cl?$AA@
	push	OFFSET ??_C@_0BK@OHCKHDJD@Error?3?5failed?5to?5open?5?$CFs?6?$AA@
	call	_printf
	add	esp, 8

; 92   : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN25@cl_build_p:
$LN4@cl_build_p:

; 93   : 	}
; 94   : 
; 95   : 	f.seekg (0, std::ios::end);

	push	2
	lea	esi, DWORD PTR _f$[ebp]
	call	?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg

; 96   : 	size_t size = (size_t) f.tellg();

	lea	esi, DWORD PTR $T37201[ebp]
	lea	eax, DWORD PTR _f$[ebp]
	call	?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ ; std::basic_istream<char,std::char_traits<char> >::tellg
	mov	edi, DWORD PTR [eax+8]
	add	edi, DWORD PTR [eax]

; 97   : 	f.seekg (0, std::ios::beg);

	push	0
	lea	esi, DWORD PTR _f$[ebp]
	call	?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg

; 98   : 
; 99   : 	if (size == 0)

	test	edi, edi
	jne	SHORT $LN3@cl_build_p

; 100  : 	{
; 101  : 		printf("Error: %s is empty\n", source);

	push	OFFSET ??_C@_0BB@GKNLBPKG@?4?1aes?9encrypt?4cl?$AA@
	push	OFFSET ??_C@_0BE@BCOEJPJH@Error?3?5?$CFs?5is?5empty?6?$AA@
	call	_printf
	add	esp, 8

; 102  : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN26@cl_build_p:
$LN3@cl_build_p:

; 103  : 	}
; 104  : 
; 105  : 	char *source_str = new char[size];

	push	edi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 106  : 
; 107  : 	f.read(source_str, size);

	push	0
	push	edi
	push	eax
	lea	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	DWORD PTR _source_str$[ebp], eax
	call	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z ; std::basic_istream<char,std::char_traits<char> >::read

; 108  : 
; 109  : 	program = clCreateProgramWithSource(context, 1, (const char **) &source_str,
; 110  : 	                                    NULL, &err);

	mov	eax, DWORD PTR _context
	push	OFFSET _err
	push	0
	lea	edx, DWORD PTR _source_str$[ebp]
	push	edx
	push	1
	push	eax
	call	DWORD PTR __imp__clCreateProgramWithSource@20
	mov	DWORD PTR _program, eax

; 111  : 	if ( ! program) {

	test	eax, eax
	jne	SHORT $LN2@cl_build_p

; 112  : 		printf("Error: failed to create compute program\n");

	push	OFFSET ??_C@_0CJ@FJBOGDEN@Error?3?5failed?5to?5create?5compute?5@
	call	_printf
	add	esp, 4

; 113  : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 114  : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN27@cl_build_p:
$LN2@cl_build_p:

; 115  : 	}
; 116  : 
; 117  : 	err = clBuildProgram(program, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	eax
	call	DWORD PTR __imp__clBuildProgram@24
	mov	DWORD PTR _err, eax

; 118  : 	if (err != CL_SUCCESS) {

	test	eax, eax
	je	SHORT $LN1@cl_build_p

; 119  : 		size_t len;
; 120  : 		char buffer[1024 * 10]; // error message buffer, 10 KiB
; 121  : 
; 122  : 		clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG,
; 123  : 		                      sizeof(buffer), buffer, &len);

	mov	eax, DWORD PTR _device_id
	lea	ecx, DWORD PTR _len$24589[ebp]
	push	ecx
	mov	ecx, DWORD PTR _program
	lea	edx, DWORD PTR _buffer$24590[ebp]
	push	edx
	push	10240					; 00002800H
	push	4483					; 00001183H
	push	eax
	push	ecx
	call	DWORD PTR __imp__clGetProgramBuildInfo@24

; 124  : 
; 125  : 		printf("Error: failed to create program executable\n%s\n", buffer);

	lea	edx, DWORD PTR _buffer$24590[ebp]
	push	edx
	push	OFFSET ??_C@_0CP@OFECIAMI@Error?3?5failed?5to?5create?5program?5@
	call	_printf
	add	esp, 8

; 126  : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 127  : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN28@cl_build_p:
$LN1@cl_build_p:

; 128  : 	}
; 129  : }

	lea	ecx, DWORD PTR _f$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@cl_build_p:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?cl_build_program@@YAXXZ$0:
	lea	ecx, DWORD PTR _f$[ebp]
	jmp	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$?cl_build_program@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-10476]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?cl_build_program@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?cl_build_program@@YAXXZ ENDP				; cl_build_program
PUBLIC	?cl_init@@YAXPADPAEII@Z				; cl_init
; Function compile flags: /Ogtp
;	COMDAT ?cl_init@@YAXPADPAEII@Z
_TEXT	SEGMENT
_kernel_name$ = 8					; size = 4
?cl_init@@YAXPADPAEII@Z PROC				; cl_init, COMDAT
; _roundkeys_length$ = edi

; 133  : {

	push	ebp
	mov	ebp, esp

; 134  : 	if (program == nullptr)

	cmp	DWORD PTR _program, 0
	push	esi
	jne	SHORT $LN7@cl_init

; 135  : 	{
; 136  : 		cl_build_program();

	call	?cl_build_program@@YAXXZ		; cl_build_program
$LN7@cl_init:

; 137  : 	}
; 138  : 
; 139  : 	// Create the compute kernel in the program
; 140  : 	kernel = clCreateKernel(program, kernel_name, &err);

	mov	eax, DWORD PTR _kernel_name$[ebp]
	mov	ecx, DWORD PTR _program
	push	OFFSET _err
	push	eax
	push	ecx
	call	DWORD PTR __imp__clCreateKernel@12
	mov	DWORD PTR _kernel, eax

; 141  : 	if ( ! kernel || err != CL_SUCCESS) {

	test	eax, eax
	je	$LN5@cl_init
	cmp	DWORD PTR _err, 0
	jne	$LN5@cl_init

; 145  : 	}
; 146  : 
; 147  : 	// Create buffers
; 148  : 	state = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR, 
; 149  : 		                   state_length, NULL, &err);

	mov	edx, DWORD PTR _context
	mov	esi, DWORD PTR __imp__clCreateBuffer@24
	push	OFFSET _err
	push	0
	push	128					; 00000080H
	push	0
	push	17					; 00000011H
	push	edx
	call	esi

; 150  : 	if (err != CL_SUCCESS)

	cmp	DWORD PTR _err, 0
	mov	DWORD PTR _state, eax
	je	SHORT $LN4@cl_init

; 151  : 	{
; 152  : 		printf("Error: failed to allocate device memory (state, size: %lu)\n",
; 153  : 		       state_length);

	push	128					; 00000080H
	push	OFFSET ??_C@_0DM@EFGFDLFN@Error?3?5failed?5to?5allocate?5device@
	call	_printf
	add	esp, 8

; 154  : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 155  : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN11@cl_init:
$LN4@cl_init:

; 156  : 	}
; 157  : 	
; 158  : 	roundkeys = clCreateBuffer(context, CL_MEM_READ_ONLY, roundkeys_length, NULL, 
; 159  : 		                       &err);

	mov	eax, DWORD PTR _context
	push	OFFSET _err
	push	0
	push	edi
	push	0
	push	4
	push	eax
	call	esi

; 160  : 	if (err != CL_SUCCESS)

	cmp	DWORD PTR _err, 0
	mov	DWORD PTR _roundkeys, eax
	je	SHORT $LN3@cl_init

; 161  : 	{
; 162  : 		printf("Error: failed to allocate device memory (roundkeys, size: %lu)\n",
; 163  : 		       roundkeys_length);

	push	edi
	push	OFFSET ??_C@_0EA@GEPEPEEL@Error?3?5failed?5to?5allocate?5device@
	call	_printf
	add	esp, 8

; 164  : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 165  : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN12@cl_init:
$LN3@cl_init:

; 166  : 	}
; 167  : 
; 168  : 	// Bind buffers
; 169  : 	err = clSetKernelArg(kernel, 0, sizeof(cl_mem), &state);

	mov	ecx, DWORD PTR _kernel
	mov	esi, DWORD PTR __imp__clSetKernelArg@16
	push	OFFSET _state
	push	4
	push	0
	push	ecx
	call	esi
	mov	DWORD PTR _err, eax

; 170  : 	if (err != CL_SUCCESS)

	test	eax, eax
	je	SHORT $LN2@cl_init

; 171  : 	{
; 172  : 		printf("Error: failed to bind kernel argument \"buffer\" [#0]\n");

	push	OFFSET ??_C@_0DF@KBMIDIFJ@Error?3?5failed?5to?5bind?5kernel?5arg@
	call	_printf
	add	esp, 4

; 173  : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 174  : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN13@cl_init:
$LN2@cl_init:

; 175  : 	}
; 176  : 
; 177  : 	err = clSetKernelArg(kernel, 1, sizeof(cl_mem), &roundkeys);

	mov	edx, DWORD PTR _kernel
	push	OFFSET _roundkeys
	push	4
	push	1
	push	edx
	call	esi
	mov	DWORD PTR _err, eax

; 178  : 	if (err != CL_SUCCESS)

	test	eax, eax
	je	SHORT $LN1@cl_init

; 179  : 	{
; 180  : 		printf("Error: failed to bind kernel argument \"roundkeys\" [#1]\n");

	push	OFFSET ??_C@_0DI@CKFCGCAA@Error?3?5failed?5to?5bind?5kernel?5arg@
	call	_printf
	add	esp, 4

; 181  : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 182  : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN14@cl_init:
$LN5@cl_init:

; 142  : 		printf("Error: failed to create compute kernel\n");

	push	OFFSET ??_C@_0CI@JDNBEOHO@Error?3?5failed?5to?5create?5compute?5@
	call	_printf
	add	esp, 4

; 143  : 		cl_print_error(err);

	call	?cl_print_error@@YAXH@Z			; cl_print_error

; 144  : 		exit(EXIT_FAILURE);

	push	1
	call	_exit
$LN15@cl_init:
$LN1@cl_init:

; 183  : 	}
; 184  : }

	pop	esi
	pop	ebp
	ret	0
$LN10@cl_init:
?cl_init@@YAXPADPAEII@Z ENDP				; cl_init
PUBLIC	?id@?$codecvt@DDH@std@@2V0locale@2@A		; std::codecvt<char,char,int>::id
;	COMDAT ?id@?$codecvt@DDH@std@@2V0locale@2@A
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_BSS	SEGMENT
?id@?$codecvt@DDH@std@@2V0locale@2@A DD 01H DUP (?)	; std::codecvt<char,char,int>::id
_BSS	ENDS
END
